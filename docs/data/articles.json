{"fields": ["title", "content", "tag", "desc", "tags", "created_at", "updated_at", "created_by", "id", "acl"], "data": [{"title": "结果与过程", "content": "《碟中谍全面瓦解》中有这么一段台词，主角遇到问题总是会说一句：“我会想办法”，留下其余人一脸懵。感觉什么样的困难在他那里总是能够解决，虽然剧情的走向由编剧来定，结局问题一定是被解决掉了。但是，现实生活中，又有多少人有这样的勇气？\n\n现今是一个注重结果的时代，没有人会关心你的过程，（越发觉得前辈的经验往往过了一两年之后才会在你的身上应验）没有人会去关注实现结果的过程你有多痛苦，大家总是期望遇到大圆满的结局。就如项目开发中，没人关心你加班到几点、用什么方式去实现，他们希望看到的是项目如期且没有bug上线~\n\n而在我这微小的人生经验中，越发感到，大多数事只要投入足够多的时间，发生的概率还是很大的。只是取决于你想吃的是“营养液”，还是每日三餐这样一口一口的吃完；没明白？事物是公平的，要想短期内达到效果，必然是每天都投入大量时间，这样会牺牲很多日常生活，不过是见效最快的方式。而想一步步达到目标，必然是每天投入一点，每天投入一点，这样日积月累，你也总能实现目标，只是时间上比前者多~\n\nintersting! 有趣的过程，选择权其实一直在我们手中~ ", "tag": "杂记", "desc": "剧情的走向由编剧来定，最终问题一定是被解决掉了。但是，现实生活中，又有多少人有这样的勇气？", "tags": ["杂记"], "created_at": 1560839460, "updated_at": 1561620390, "created_by": 77641313, "id": "5d08852c969dff177b24f8ed", "acl": "未开放读, 创建者可写"}, {"title": "关于网站备案", "content": "一个月的月底，到了发博文的时间。写博客文章本应成为一个习惯，现在成为一个月一篇，变得越来越懒，伸个手都觉得累~ 估计是天冷了吧~\n\n今日想谈谈域名认证与网站审核，上月底突发奇想，想搞一个自己的网站，比较“正规”的网站，有对外域名和自己的服务器，包括网站的审核，于是乎便开始了捣鼓的旅程…\n\n域名认证\n域名认证没什么好谈的，在域名购买完之后，在域名购买商实名认证就可，本人在阿里购买的域名，认证都很快，很方便。\n\n网站解析\n网站解析即将自己购买的域名与服务器IP绑定起来，DNS域名解析，将你的域名指向对应的服务器IP，由于本人域名在阿里购买，服务器为腾讯云，故而在解析的时候可能会有修改DNS域名解析服务商的提醒，按照操作执行即可。\n\n网站备案审核\n走的是个人网站审核流程，在腾讯云后台备案系统中填入相关的备案信息，因为是个人网站，故而需要填写个人相关信息。这一流程主要是腾讯云那边采集的信息。\n\n值得一提的是，其中有一步是需要将网站备案申请打印出来，个人签名然后拍照上传，如果拍照不清晰，会被打回来重新提交；\n\n另外需注意，在备案期间，网站是需要关闭的，不能对外访问。所以，在近一个月的备案时间中，服务器一直处于关闭状态，并且删除了DNS域名解析信息。\n\nnext腾讯云会有一个幕布拍照审核的流程，腾讯云那边会给你寄一个幕布，站在前边拍张照片，上传即可\n\nnext腾讯云审核通过之后会提交给当地交管局审核，这一流程比较长，毕竟政府部门，工作日才会审核\n\n本人网站备案耗时近一个月，还算顺利，基本上按要求填写即可，备案完成后会有一个备案号，可以在交管局官方网站查询到你的网站相关信息\n\n域名ssl证书生成(支持https访问)\n网站备案完成，开启网站服务，支持域名访问，突然发现不是https开头，浏览器会提示不安全网站，需要在域名注册商出生成ssl证书，并绑定到对应服务器上，即绑定到apache等相关服务，具体参考相关服务绑定流程", "tag": "技术", "desc": "谈谈域名认证与网站审核，域名认证、网站解析、网站备案审核以及域名ssl证书生成(支持https访问)", "tags": ["技术"], "created_at": 1544256360, "updated_at": 1561799969, "created_by": 77641313, "id": "5d089bbd969dff1dc601b67c", "acl": "创建者可读, 创建者可写"}, {"title": "6个残酷的人生事实", "content": "如果你的职业道路非常顺利，你的生活美满感情顺利，你可以不用读这篇文章。祝你一天愉快，这篇文章不是为你写的。你做的非常出色，我们都为你自豪。\n\n对于其余的人来说，我希望你做一件事情：说出5件你引以为豪的事情。写在纸上也好，或者喊出来也好都可以。但这里有一个条件：你不可以列出你“是”怎样的人（比如，我是一个温柔的人，我很诚实），只能列出你“做”的事情（比如，我刚获得了全国象棋冠军，我做的chili是全麻省最好的）。如果你发现很难列出五件事情，这篇文章就是为你所写的。而且你他x娘de肯定一边听一边心里会不舒服。我的感受是，如果有人在1995年的时候跟我讲这些事情就好了。\n\n## 第6个事实：这个世界只关心你能给予什么\n\n我们假设一下你最爱的亲人在大街上被枪击了。TA一边失血一边尖叫。一个路人冲上来说“让一下”。他仔细检查了伤口并拿出一把小刀准备在大街上动手术取出子弹。\n\n你问他：“你是医生吗？”\n他回答说：“不是”\n你说：“你知道你要做什么，对吧？你是不是退伍的军医，还是……”\n\n这个时候那个路人感觉有点不快了。他告诉你说他是一个好人，是一个诚实的人，他上班从来不迟到。他告诉你说他是一个孝顺的儿子。业余生活丰富，生活非常富足。他还说他从不说脏话。\n\n你有点疑惑，说：“这ta吗的和我亲人被枪击躺在马路上有什么关系？我需要一个可以在伤口上动手术的人！你到底能不能做？”\n\n现在这个路人非常生气了——为什么你就那么自私肤浅呢？你难道不在乎他的那些优良品德么？他刚才不对你说他总是记住女友的生日吗？他有那么多优良品质，你为什么就抓着他会不会外科手术这个事实不放呢？\n\n在那个疯狂的情形下，你会用你沾满鲜血的双手用力摇晃他的肩膀，大喊道：“废话！你说的那些优良品质都是屁话，因为在当前情况下我只需要一个可以止血动手术的人！你这个神经病给我滚！”\n\n所以，这就是我要说的第一点成人世界的残酷事实：你其实天天都身处于上述的“当前情况”之中。只不过换作你是那个喋喋不休的好心路人，而社会上其他所有人都换作成那个流血的伤者。\n\n如果你想知道为什么社会对你不屑，或者你为什么从不受到尊重，这是因为社会充满了 需要某样东西的人。他们需要人来造房子，他们需要食物，他们需要娱乐，他们需要人来满足性欲。你从出生开始就进入了这样的需要解决人们需求的社会系统。\n\n你要么选择学习某种技能担当某样角色满足他人的需要，要么就选择被社会抛弃。这个社会不在乎你有多么善良，礼貌，无私。你会变穷，你会没有朋友，你会被遗弃。\n但这是不是说我们要刻版、自私呢？爱和温柔重要吗？当然了，但前提是这些爱是别人需要的，也是从其他人那里得不到的。\n\n否则的话……\n\n## 第5个事实：别去相信嬉皮士的话 (Hippies are wrong)\n\n【原文此处引用了一段视频： http://v.youku.com/v_show/id_XNTIwNzE5MDg0.html ，到优酷搜索 'Glengarry Glen Ross speech' 直达，英文对白： http://yu.ac.kr/~bwlee/esc/baldwin.htm 】\n\n对于那些无法看视频的读者，这是一段著名的影院神片Glengarry Glenn Ross里Alec Baldwin的演讲。Baldwin的角色——你会假设是反角——对一屋子的销售员疯狂施压，警告他们说他们都会被解雇，除非他们可以搞定他们手上的单子。\n\n“好人？关我屁事！慈父？去你ma的！回你的家和你孩子玩去！如果你想在这里工作，给我敲定手上的单子”\n\n非常残酷、粗鲁、甚至有点疯狂。可是，这恰恰是这个社会对你期望的最诚实的写照。不同的是，在现实世界里，人们认为那样讲话太粗鲁了对你不礼貌，于是他们干脆什么都不说眼看着你失败。\n\n这个电影片段改变我的人生。我如果知道怎么做的话，会把它录成闹钟每天早上叫我起床。Baldwin因此还拿了奥斯卡奖，而这个片段是他整个电影唯一出场的场景！正如前人已经分析过，这段演讲精彩之处在于，一般的人会理解为“天哪，我要有这么一个混蛋老板会怎样啊？”。而另一半人却会想“太ta嘛励志了！我现在就想去上班做业务去！”\n\n或者，有一个心理学家写道：“如果当时你在那个房间里，你们中的一些人会明白这是工作，会从那段演讲里吸收能量，就像一个球队教练冲你大骂一样。你会觉得‘这家伙太有能耐了’。而另一些人会非常介意，认为这个老板是混蛋，你没有权利跟我这样说话。”\n以上节选自一篇对于“hipster（这个词很难翻译，姑且翻译为非主流潮人）”的批判文章。文章解释了这些人为什么会难找工作，并指出上述两种不同的态度——受刺激vs受激励——很大程度上决定你是否在现实生活中能成功。\n\n比如说，有人会引用搏击俱乐部里的经典台词“You are not your job”。但事实上，你完完全全就是你的job（职责）。当然了，你的职责和你为公司的服务不是一回事请，但其实你只不过是你所有有用技能经验的综合体罢了。技能是某一个个体能为社会中其他人提供的有用服务。但别搞错了，你的“职责”——你为他人提供的有用服务——就是你的全部。\n\n这就是为什么外科医生比喜剧作家更受到尊重。也是为什么机修工比无业潮人更受到尊重。如果你的死讯能登上新闻，这说明你的工作已经成为了你的标签。搏击俱乐部里Tyler说You are not your job，但他同时又操办了一家成功的肥皂公司同时成为了社会运动的领导人。He was totally his job （这句不翻译比较好理解）。\n\n我们再这样理解一下：你还记得Chick-fil-A餐厅反对同性恋婚姻么？不论嬉皮们如何抗议，公司还不是照样卖出了成千上万的汉堡？这不是说顾客们认可他们，而是因为他们成功地完成了履行了他们的职责——做好吃的汉堡。这一点才是最关键的。\n\n你不一定非要从心里喜欢这个事实。我也不喜欢我生日的时候天下雨。但天还是要下雨。人们有需求，人们会认可能够满足他们需求的人。世界就是通过这么简单的机制运行的，谁也改变不了。\n\n如果你抗议说，我不是肤浅的物质主义者，金钱不是万能的，我只能说：我有说过金钱吗？说明你没看懂我的要点。\n\n## 第4个事实：你所做的事情不一定要换成钱，但一定要有益于他人\n\n那么我们换一个非金钱的例子好了。这个网站(cracked.com)主要面向20出头的男性。我每天都要从邮箱里收到一大堆挫男抱怨女人不愿意接近他们，虽然他们是世界上最nice的男人。我可以解释他们的思路有什么问题，不过最好是让Alec Baldwin解释最好。\n\n（译注：此处再次引用上述视频，我真的建议大家去看那个片段！）\n\n在我们说的例子里，Baldwin就是你生活里那个女神。他们当然不会像Baldwin的角色那样粗鲁直接——社会教育我们不要对别人那么“诚实”——但问题是一样的：“你是好人？关我屁事！想在这里工作，就给我搞定工作。”\n\n所以，你有什么感想呢？你对在书店里遇到的女神每天白日梦YY，为她午餐不吃色拉感到惋惜。她10年后会成为一个外科医生，你呢？\n\n“什么？你是说除非我找到一个好工作赚大钱否则不可能把到女神？”\n\n不！你的大脑跳跃太快了，因此你可以给自己一个理由认为所有拒绝你的女神都是肤浅自私的。我在这里就问一个问题：你给予了什么？你聪明么？幽默吗？情趣吗？天才？雄心？创意？好，那你做什么事情能向这个世界证明自己的优点呢？不要跟我说你是个好人——这是最起码的。你的女神每天有三打的男人对她“好”。用我们上文的例子来说，伤者在大街上流血，你到底会不会开刀？\n\n“我不歧视女人，不歧视种族，不贪婪，不肤浅，也不虐待人！我和那些diao不垃几的男人不一样。”\n很抱歉，如果你所能做的事情只不过是你“没有”一堆缺点，就ta吗的给我从伤者身边滚出去！我们有的是风趣、英俊、事业成功的男人来帮助你的女神。\n\n伤到你自尊了么？有一点？那现在怎样呢？你想碎碎念呢，还是打算学习怎么去做手术治疗那个伤者？取决于你。但你不要去抱怨为什么女神就喜欢找你口中的坏男人。她们吃这套是因为那些diao不拉几的男人有其他东西可以满足你的女神。“但我是一个聆听者！”是吗？你可以坐在女神身边几个小时听她念叨？你猜怎么着？角落里还有另一个男人可以这样做，他还是吉他高手！你如果不停地说你是一个好人，就像一个餐厅说他们的卖点是他们的食物不会让你拉肚子一样，就像一部电影的标题是“This Movie is in English”。\n\n这就是为什么你可以做一个好人但仍然觉得自己是loser。\n\n## 第3个事实：你恨自己是因为你无所作为\n\n“所以你的意思是要我去买一本教我如何把妹的书么？”\n当然不是，除非那本书的第一章是“让自己变成女孩子愿意接近的人”。因为这一步总是容易被忽略——人们总是问“我怎么能找到工作？”而不是“我如何成为雇主愿意雇用的人？”；人们总是问“怎么让女孩喜欢我？”而不是“我怎么成为女孩喜欢的人？”。对吧？因为后者往往要求你放弃自己喜欢的爱好，注重外表，天知道还要做其他什么牺牲。你甚至还可能要改变你的天性。\n\n“但是为什么我不能就去找一个喜欢原本的我的人呢？”答案很简单：人是有需求的。别忘记我们的例子：伤者在流血，而你所做的只是抱怨找不到会自动愈合的伤口？\n\n【此处插入一段Youtube上点击率很高的猥琐街头艺人表演的视频】\n\n每个人看了上面这段视频都会会心一笑。你能为人们带来笑声么？为什么不呢？是为什么阻止你穿上猥琐的衣服在街头边唱边甩鸡鸡呢？那家伙似乎知道赢得掌声的门道……做怪事……总比什么都不做好……\n\n“但是我什么都不擅长！”我有好消息告诉你：如果你尝试反复练习做一件事情，任何事情，你都可以擅长此事。我小时候可能是全世界最糟糕的作者。到了25岁的时候稍微好那么一点点。但当我职场失意的时候，我用业余时间写作长达八年，一周写一篇文章，直到它为我换回了钞票。我花了13年时间才能登上纽约时报畅销书榜单。我大概花了20000个小时才慢慢磨快了我拙劣的文笔。\n\n不希望花那么多时间磨练一门技术？那么我有好消息和坏消息告诉你。好消息是漫长的磨练可以让你慢慢走出困境——我忍受了多年琐碎的办公室工作，因为我知道我同时在学习一门技能。人们半途而废是因为要看到结果实在是太漫长了，同时也是因为他们没有意识到“结果”就是过程本身。\n坏消息是你别无选择。“想继续在这里工作？给我搞定手里的单子”\n\n从我个人角度出发看，你并不是因为缺乏自信而恨自己，或者是因为别人羞辱你。你恨自己是因为你【什么都不做】。连你自己都不能爱“原本的自我”——这就是为什么你很可悲，不断写私信问我如何处理你的生活问题。\n\n自己扳手指算一下：你有多少时间是在消费别人创造的东西（电视，音乐，电玩，网站）而不是生产你自己的东西？只有你的“产出”才能为你添加作为人的价值。\n\n如果你听到这里听不下去了，并且用你从小听到大的陈词滥调回应说：“人的内在才是最重要的”，那么我只能说……（接下文）\n\n## 第2个事实：你的内在只有通过所做的事情才能表现出来\n\n在我所从事的行业里，我认识无数有理想的作家。他们认为自己是作家，他们在聚会上介绍自己是作家，他们拥有一颗作家的热心。他们只缺乏最后的一步：写点ta吗的像样的东西出来。\n\n是吗？难道“写点东西”就是真正决定谁是谁不是真正“作家”的标准吗？\n我的天哪，当然是了！\n\n这恰恰是对我以上所说一切最常见的反驳，也是对你生活中批评声音最常见的反驳。这是你不断对你自己暗示以逃避能帮你改善自我的刻苦工作的理由。“我知道我的内在是一个很好的人”。你也会听到人说“我做我自己”。\n\n不要误会我的意思：你的内在非常重要。一个男人如果为了他的家庭从无到有造出一栋房子完全是因为他的内在是一个好人。你所做的一切坏事最初是一个坏的念头，萦绕在你脑中，直到最后实施。同样，做一件好的事情也是一样道理——内在的自我是你成功果实赖以生长的土壤。\n\n但是所有人都应该知道，所有人却都不能接受的事实是：“没有最后的果实，你就什么都不是”\n\n比如你内心非常同情穷人。很伟大。这会让你最后做什么实事么？你听到你社区里一些悲剧发生后，你会说“这些不幸的孩子啊，让他们知道我在内心同情他们”吗？你要这么说我就只好说法克you——给我去真正帮助他们才是真的。数以千万的人看了那段Kony视频（译注：2012年Youtube上很有争议的关于非洲儿童的视频），所有看过的人都“在心里同情他们”。那么这么强大的同情给儿童们带来了什么呢？屁都没有！每天有非洲的儿童死于非命，因为数以百万的我们对自己说关心和行动一样重要。这是我们内心的一种心理机制，控制着我们大脑里犯懒的那一部分，让我们不断逃避真正去做实事。\n\n有多少人此刻正在想：“她（他）如果知道我是多么有趣的人，一定会爱上我。”真的吗？你那些有趣的想法有多少让世人知道了呢？如果你的心上人有一个隐藏摄像机跟着你拍一个月，他们会被录影的内容打动吗？记住，人们不会读心术，他们只会观察你的行动。\n\n我希望你做的，只不过是用你看别人的标准来看你自己罢了。你有没有一个烦人的基督徒朋友给别人最大的帮助只不过是“我为你祈祷”？你觉得烦不烦？我这里还没涉及到祈祷是不是实际有用呢，他们提供的帮助不需要他们屁股离开沙发就可以做。他们认为自己思想纯净，但是他们纯净的思想土壤有没有结出果实呢？他们自己应该比别人更清楚这点——因为我“土壤-果实”的比喻就是从圣经里拿来的。圣经里耶稣曾经不止一次说过“人们是根据果实来评判一颗树的”。当然，耶稣从来不会说“想继续留在这里工作，就给我搞定单子”，但他说“凡不结好果实的树，都要砍下來，扔在火里。”\n\n对以上这些话无动于衷的人，就如同电影里对Baldwin无动于衷的业务员一样。\n\n## 第1个事实： 人的内心其实一直在拒斥进步\n\n人类的大脑是很神奇的。但你会发现大脑在拒斥进步的时候运转得比做实事的时候还快。你的意识会通过层层防御机制来排斥任何会让你改变现状的事情——问一下对任何事物有瘾头的人就知道了。\n\n所以，到现在，你们中的许多人一边读这篇文章，一边会感觉到大脑在不断提供排斥这篇文章的理由。从经验上说，这些想法通常是：\n\n有意将任何批评理解为侮辱\n“他凭什么说我又懒又没用？一个善良的人从来不会这样对我说话！作者写这些东西只不过是想显示自己有多么优越，让我这个loser对自己生活不满罢了！等我回复更损人的话给你！”\n\n对人不对事\n“这人有什么资格告诉我怎么活？他自以为自己了不起吧？不过是网上的一个白痴写手罢了！我要去人肉他，看他有什么丑事可以抖出来。这人真自以为是，让我作呕”\n\n只看语气，不看内容\n“我会仔细看你的文章，找出一句话，断章取义只讨论那个。”\n\n不断修饰你的过去\n“事情没那么糟糕。确实我上个月还想自杀呢，但现在我感觉好多了！也许我只要继续做我现在做的事情，情况会好的。让我继续给那个女神修电脑，女神总会到我身边的！”\n\n认为改善生活的行为总会让你失去自我\n“哦，那么你是让我扔掉所有的漫画书。天天去健身房6小时？因为除此之外我没选择了？”\n\n当然还有其他的想法。记住： 痛苦是会让人感到舒坦的。许多人选择拥抱痛苦。幸福是需要努力的。\n\n还有：勇气。人们无法批评你根本没有去创造出来的东西，所以人们选择什么都不做来避免批评。\n人们很容易双手一叉裤袋批评别人的工作。这个电影很傻，这对父母的小孩很皮，那对情侣的感情很糟糕，那个暴发户不学无术，这个餐厅糟透了，本文作者是个白痴，我倒不如留一条损的回复让网站开除他，瞧，我这不“创造”了一些东西么？\n\n哦，是啊，我忘记提醒你了。不论你尝试建造或者创造什么东西——诗歌也好，新的技术也好，或者新的感情也好——你会立刻发现自己身边多了很多批评家。这些批评家也许不会当你面损你，但是他们确实在挖苦你。你的酒鬼朋友不希望你清醒，你肥胖的朋友不希望你苗条，你无业的朋友不希望看到你开始新的职业。\n\n记住，他们不过在表达他们对生活的恐惧罢了，批评别人的工作是自己不作为的另一个理由。“为什么我要创造什么东西呢，你看别人做的东西都糟透了！”“我想写小说，不过我要等时机，我可不想写出暮光那样肤浅的东西”。只要他们永远不动手去做事情，事情就永远是完美的。或者他们如果真的着手做事情了，他们会故意不努力，让别人认为事情做不好是因为他们不在状态，“他们真正的潜力是无穷的”，不是你看到的狗屎一样的产品。\n\n往下翻读一下本文的回复——那些很极端的回复，永远都是“Cracked应该炒了这个作者”“这个自负的白痴应该停止写作”。所有一切的负面评论潜台词永远都是“停止创作，如果换我来创作绝对比这个好千倍，你现在得到那么多人气让我自己很没面子。”\n\n不要成为上述的那种人。如果你是那种人，请不要继续成为那样的人。这正是人们为什么不喜欢你的原因，这正是你恨自己的原因。\n\n所以，我有个建议：给自己定一个期限，2013年底，或者从你读本文之后的一年。当别人跟你说“我的新年计划是减肥15磅”的时候，我说咱们应该努力去做任何一件事情——学习新的技能直到足够有用为止，或者随便选一件事情：学空手道，学跳舞，学陶艺，做一个鸟屋，学习按摩，学一门语言，甚至拍一部A pian，做蝙蝠侠打击犯罪……\n\n关键在于：我不希望你把眼光放在某个过高的目标上，我希望你专注于获得一样新的， 对其他人有用的技能和经验。\n\n“我没钱参加烹饪班”，那就ta吗的给我Google“如何烹饪”。我的天，拜托你戒掉这些借口，否则这些借口就要你命了。（You have to kill those excuses, or they will kill you）", "tag": "杂记", "desc": "我希望你做一件事情：说出5件你引以为豪的事情。写在纸上也好，或者喊出来也好都可以。", "tags": ["杂记"], "created_at": 1530628860, "updated_at": 1561620408, "created_by": 77641313, "id": "5d08f860f10499540cff3a30", "acl": "未开放读, 创建者可写"}, {"title": "史记·河渠书", "content": "《夏书》记载：禹治理洪水经历了十三年，其间路过家门口也不回家看望亲人。行陆路时乘车，水路乘船，泥路乘橇，山路坐轿，走遍了所有地方。从而划分了九州边界，随山势地形，疏浚了淤积的大河川，根据土地物产确定了赋税等级。使九州道路通畅，筑起了九州的泽岸，度量了九州山势。然而还有黄河泛滥成灾，给中国造成很大危害。于是集中力量治理黄河，引导河水自积石山经过龙门，南行到华阴县，东下经砥柱山和孟津、雒汭，到达大邳山。禹以为大邳以上黄河流经的地区地势高，水流湍急，难以在大邳以东的平地经过，否则会时常败堤破岸，造成水灾，于是将黄河分流成二条河以减小水势，并引水北行，从地势较高的冀州地区流过，经降水，到大陆泽，以下开九条大河，\n\n　　共同迎受黄河之水，流入勃海。九州河川都已疏通，九州大泽都筑了障水堤岸，华夏诸国得到治理而安定，其功绩使夏、商、周三代受益不绝。\n\n　　后人又自荥阳以下引河水东南流，成为鸿沟，把宋、郑、陈、蔡、曹、卫各国连结起来，分别与济、汝、淮、泗诸水系交会。在楚地，西方在汉水和云梦泽之间修渠连通，东方则在江淮之间用沟渠相连。在吴地于三江、五湖间开凿河渠。在齐则于菑、济二水间修渠。在蜀，有蜀守李冰凿开离堆，以避沫水造成的水灾；又在成都一带开凿二条江水支流。这些河渠水深都能行舟，有余 就用来灌溉农田，百姓获利不小。至于渠水所过地区，人们往往又开凿一些支渠引渠水灌田，数目之多不下千千万万，但工程小，不足数计。\n西门豹引漳水灌溉邺郡的农田，使魏国的河内地区富裕起来。\n\n　　韩国听说秦国好兴办工役等新奇事，想以此消耗它的国力，使它无力对山东诸国用兵，于是命水利工匠郑国找机会游说(shuì，税)秦国，要它凿穿泾水，从中山(今陕西泾阳县北)以西到瓠(hù，户)口，修一条水渠，出北山向东流入洛水长三百余里，欲用来灌溉农田。渠未成，郑国的目的被发觉，秦国要杀他，郑国说：“臣开始是为韩国做奸细而来，但渠成以后确实对秦国有利。”秦国以为他说得对，最后命他继续把渠修成。渠成后，引淤积混浊的泾河水灌溉两岸低洼的盐碱地四万多顷，亩产都达到了六石四斗。从此关中沃野千里，再没有饥荒年成，秦国富强起来，最后并吞了诸侯各国，因把此渠命名为郑国渠。\n\n　　汉朝建立后三十九年，到孝文帝时黄河堤决于酸枣县，向东冲溃金堤，于是东郡动员了许多兵卒堵塞决口。\n\n　　此后过了四十多年，到本朝天子元光年间，黄河在瓠子决口，向东南流入钜野泽，将淮河、泗水连成一片。于是天子命汲黯、郑当时调发人夫、罪徒堵塞决口，往往堵塞以后又被冲坏。那时朝中的丞相是武安侯田蚡(fén，坟)，他的奉邑是鄃(shū，舒)县，以鄃县租税为食。而鄃县在黄河以北，黄河决口水向南流，鄃县没有水灾，收成很好。所以田蚡对皇帝说：“江河决口都是上天的事，不易用人力强加堵塞，即便将决口堵塞了，也未必符合天意。”此外望云气和以术数占卜的人也都这样说。因此天子很长时间没有提堵塞决口的事。\n\n　　那时郑当时任大司农职，说道：“往常从关东漕运的粮食是沿渭水逆流而上，运到长安估计要用六个月，水路全程九百多里，途中还有许多难行的地方。若从长安开一条渠引渭水，沿南山而下，直到黄河才三百多里，是一条直道，容易行船，估计可使漕船三个月运到；而且沿渠农田一万多顷得到灌溉。这样既能减少漕省运粮的兵卒，节省开支，又能使关中农田更加肥沃，多打粮食。”天子认为说得对，命来自齐地的水利工匠徐伯表测地势，确定河道走向，动员全部兵卒数万人开凿漕渠，历时三年完工，通水后，用来漕运，果然十分便利。此后漕渠渐渐多起来，渠下的老百姓都颇能得到以水溉田的利益。\n\n　　后来河东守番系说：“从山东漕运粮米西行入关，每年一百多万石，中间经过砥柱这个行船的禁限地区，有许多漕船船坏人亡，而且运费也太大。若穿渠引汾水灌溉皮氏、汾阴一带的土地，引黄河水灌溉汾阴、蒲坂一带的土地，估计可以造田五千顷。这五千顷田原来都是河边被遗弃的荒地，老百姓只在其中打草放牧，如今加以灌溉耕种，估计可得粮食二百万石以上。这些粮食沿渭水运入长安，与直接从关中收获的没有两样，而不再从砥柱以东漕粮入关。”天子同意他的意见，动员兵卒数万人造渠田。几年以后，黄河改道，渠无水，种渠田的连政府贷给的种子也难以偿还。久而久之，河东渠田完全报废，朝廷把它分给从越地内迁的百姓耕种，使少府能从中得到一点微薄的租赋收入。\n\n　　以后有人上书，是为了想打通褒斜道以及漕运的事，天子交给御史大夫张汤，张汤详细了解后，说道：“从汉中入蜀向来走故道，故道有许多山坂大坡，曲折路远。今若凿穿褒斜道，山坂坡路少，比故道近四百里的路程；而且褒水与沔水相通，斜水与渭水相通，都能通行漕船。漕船从南阳沿沔水上行驶入褒水，从褒水登陆到斜水旱路一百多里，以车转运，再下船顺斜水下行驶入渭水。这样不但汉中的粮食可以运来，山东的粮食从沔水而上没有禁限，比经砥柱漕运方便。而且褒斜地区的木材箭竹，其富饶可以与巴蜀相比拟。”天子认为有道理，封张汤的儿子卬(áng，昂)为汉中郡太守，调发数万人开出一条长五百多里的褒斜道。果然方便而且路程近，但是水流湍(tuān)急多石，不能通漕。\n\n　　此后庄熊罴说：“临晋地区的老百姓愿意凿穿洛水筑成水渠，用来灌溉重泉以东原有的一万多顷盐碱地。倘若果然能得水灌溉，可使每亩产量达到十石。”于是调发兵卒一万多人开渠，自徵城引洛水到商颜山下。由于土岸容易塌方，于是沿流凿井，最深有的达到四十多丈。许多地方都凿了井，井下相互连通，使水通行。水从地下穿商颜山而过，东行直到山岭之中十多里远。从此产生了井渠。凿渠时曾掘出了龙骨，所以给此渠命名为龙首渠。这条渠筑了十多年，颇有些地方通了水，但是并未得到太大的好处。\n\n　　自从黄河在瓠子决口后二十多年，每年土地都因水涝没有好收成，梁楚地区更为严重。天子既已封禅，并巡祭了天下名山大川，第二年，天由于要晒干泰山封土而少雨。于是命汲仁、郭昌调发兵卒数万人堵塞瓠子决口，阻止水涝，天子从万里沙祠祷神以后，回来的路上亲临黄河决口处，沉白马、玉璧于河中祭奠河神，命群臣及随从官员自将军衔以下，都背负柴薪，填塞决口。当时东郡百姓以草为炊，柴薪很少，因而命砍伐淇园的竹子作为塞决口的楗。\n\n　　天子既然亲临决河处，悼念塞河不能成功，作歌道：“瓠子河决啊有何办法，浩浩汗汗啊民居已尽为河。尽为河啊地方不安，河工无休止啊吾山已经凿平。吾山已平啊钜野泽外流，水族喧嚷啊迫天齐日。河道废弛啊水离常流，蛟龙驰骋啊正远游。水归旧道啊神福滂沛，若不封禅啊怎知此事！为我告河伯啊因何不仁，泛滥不止啊愁煞人。河浸齧(niè，聂)桑啊淮、泗水满，久不归故道啊唯愿水流稍缓。”另一首是：“河水汤汤(shāng，商)啊流急，北渡回曲啊疏浚难。揭草埽于决口啊沉美玉于河，河伯纵许息水啊奈薪柴不足。薪柴不足啊卫人获罪，民烧柴尚不足啊如何御水！伐淇园之竹啊楗阻石柱，堵塞宣房啊万福来。”于是塞住了瓠子决河，在决口处筑了一座宫殿，取名为宣房宫。并修二条渠引河水北行，恢复了禹时的样子，梁、楚地区重又得到安宁，没有水灾了。\n\n　　从此以后，负责河渠事的官员争相建议修筑水利。朔方、西河、河西、酒泉等地都引黄河以及川谷中的水灌溉农田；而关中的辅渠、灵轵渠引诸川中的水；汝南、九江地区引淮河水；东海郡引钜定泽水；泰山周围地区引汶水。各自所开渠都能灌溉农田万余顷。其他小渠以及劈山通水道的，不可尽言。但工程最大的还是宣房治河的工程。\n\n\n　　太史公说：“我曾南行登上庐山，观看禹疏导九江的遗迹，随后到会稽太湟，上姑苏台，眺望五湖；东行考察了洛汭(ruì，锐)、大邳，逆河而上，走过淮、泗、济、漯、洛诸水；西行瞻望了西蜀地区的岷山和离堆；北行自龙门走到朔方。深切感到：水与人的利害关系太大了！我随从皇帝参加了负薪塞宣房决口那件事，为皇帝所作《瓠子》诗感到悲伤，因而写下了《河渠书》。\n\n中国水博——龙施雨沛", "tag": "杂记", "desc": "《夏书》记载：禹治理洪水经历了十三年，其间路过家门口也不回家看望亲人。", "tags": ["杂记"], "created_at": 1526136780, "updated_at": 1561620420, "created_by": 77641313, "id": "5d08fb2af1049954aff69580", "acl": "未开放读, 创建者可写"}, {"title": "shanghai tourist", "content": "#### 多图预警，流量党慎入\n\n三天两夜上海之旅匆匆而过，旅行总是美妙的，让你置身于一个场景中，放松身心，将日常工作的烦恼短暂抛开。\n\n初到上海，感受最深的便是它庞大的地铁系统。感觉无论去什么地方，地铁都可以将你带到目的地，当然与之而来的是庞大的客流量，可以想象每日上班族忙忙碌碌挤地铁的身影。\n\n### 上海地铁\n\n一张上海地铁图可以感受下。四通八达……\n\n![shanghai_01](http://img.wdcorner.cn/shanghai_01.JPG)\n\n### 世博园\n\n夜晚，世博园，但已关门，如果想去内部看的话可以早点去，不过夜晚可以看到黄浦江的夜景。观景台上，凉凉微风，迷人风光。\n\n![shanghai_02](http://img.wdcorner.cn/shanghai_02.JPG)\n![shanghai_03](http://img.wdcorner.cn/shanghai_03.JPG)\n![shanghai_04](http://img.wdcorner.cn/shanghai_04.JPG)\n![shanghai_05](http://img.wdcorner.cn/shanghai_05.JPG)\n![shanghai_06](http://img.wdcorner.cn/shanghai_06.JPG)\n\n总有感觉当假期有时间了，但人也多了，五一看的更多不是风景，而是人潮......\n一年又一年，大家在抱怨五一假期人山人海时，同时也背起行囊，规划着自己的出行。而在我看来，旅行看景已不是那么重要，走过形形色色的不少地方，早已清楚，各地风景大多千篇一律，有特色的也就那么一两个独有地儿，大部分都包裹着严重的商业气息，在这儿可以看到的，别的地方也一样可以遇到。吸引我的可能更多是人与人的交流，三两好友，久别重逢，聊聊近况，谈谈明日，互联网将人与人的距离拉近了，但又拉远了，因为沟通方式太容易，反而我们不愿意去主动交流。\n\n### 上海博物馆\n\n上海博物馆(排了一个多小时进去)，集各地文物精华于一身，但又有自身的良褚文化，正如上海的特性，包容，海纳百川。\n\n![shanghai_07](http://img.wdcorner.cn/shanghai_07.JPG)\n![shanghai_08](http://img.wdcorner.cn/shanghai_08.JPG)\n![shanghai_09](http://img.wdcorner.cn/shanghai_09.JPG)\n![shanghai_10](http://img.wdcorner.cn/shanghai_10.JPG)\n![shanghai_11](http://img.wdcorner.cn/shanghai_11.JPG)\n\n### 南京路步行街\n\n南京路步行街，有意思的是感觉上海的每一条路，每一道街都能找到全国的对应地，比如天津路，四川路等等。\n\n![shanghai_12](http://img.wdcorner.cn/shanghai_12.JPG)\n![shanghai_13](http://img.wdcorner.cn/shanghai_13.JPG)\n![shanghai_14](http://img.wdcorner.cn/shanghai_14.JPG)\n\n大上海的繁荣可能在这一条街有着更为直观的体现……\n\n![shanghai_15](http://img.wdcorner.cn/shanghai_15.JPG)\n![shanghai_16](http://img.wdcorner.cn/shanghai_16.JPG)\n\n### 上海外滩\n\n外滩，站在外滩，看着对岸的东方明珠，海上驶来驶去的船舶。\n![shanghai_17](http://img.wdcorner.cn/shanghai_17.JPG)\n![shanghai_18](http://img.wdcorner.cn/shanghai_18.JPG)\n![shanghai_19](http://img.wdcorner.cn/shanghai_19.JPG)\n\n陈毅市长，上海第一任市长\n\n![shanghai_20](http://img.wdcorner.cn/shanghai_20.JPG)\n\n### 上海东方明珠\n\n东方明珠电视塔，人人都想登上去在高处看看上海这座城，但人山人海，可能与我文艺范气息不太相符，拍了张合影，匆匆离去……\n\n![shanghai_21](http://img.wdcorner.cn/shanghai_21.JPG)\n\n世界金融中心，有钱人的世界我们想象不到。\n\n![shanghai_22](http://img.wdcorner.cn/shanghai_22.JPG)\n![shanghai_23](http://img.wdcorner.cn/shanghai_23.JPG)\n\n### 士兵兄弟\n\n在烈日下坚守岗位的士兵兄弟，为你们点赞！\n\n![shanghai_24](http://img.wdcorner.cn/shanghai_24.JPG)\n\n老了，当年六小时爬华山的记录已不复存在，走几步路就喊累……\n遂早早乘车打道回府，迎接接下来新的挑战。\n![shanghai_25](http://img.wdcorner.cn/shanghai_25.JPG)\n\n楞是把博客写成了游记，完。。。", "tag": "游记", "desc": "旅行总是美妙的，让你置身于一个场景中，放松身心，将日常工作的烦恼短暂抛开", "tags": ["游记"], "created_at": 1525139820, "updated_at": 1561620430, "created_by": 77641313, "id": "5d08fc09f1049954aff696f4", "acl": "未开放读, 创建者可写"}, {"title": "非凡匠心", "content": "![非凡匠心](http://img.wdcorner.cn/20180406.jpg)\n\n今日还是想谈谈匠心，由“非凡匠心”中《龙泉宝剑》一集得出的感悟。刚好，做的项目遇到了各种各样的问题（项目的进度远远超过了原先的预期，同时由于第一次做小程序的项目，遇到了一些不知所以然的问题，今日怕是又要耗些时间），索性谈谈关于这一集的感悟换换头脑。\n\n这一期的嘉宾是有张国立、任贤齐前往浙江龙泉铸剑之地，拜访陈阿金师傅，一位铸剑铸了50多年的老师傅。文化传承人。\n\n在铸剑的过程中，每一把剑都需要成百上千次的反复敲打锻造最终成型。铸剑的过程即便有丝毫的失误，也得重新再来...节目中张国立和任贤齐在第一次锻造过程中，因为一次小小的失误，铸剑的铁无法继续锻造，只能重头再来。而一个铸剑师，要想达到炉火纯青的锻造手艺，中间重头再来的经历又何止千百次？而要想把铸剑一门的手艺发扬光大，更离不开日积月累反复的研磨、试错，不断的调整、不断的重头再来。\n\n忽的感觉，每个行业不都是这样么？就如同程序员行业，脑力行当，但同时又和铸剑又和区别呢？每一次的项目便等同于一次铸剑，于是我们便开始日复一日的敲代码实现功能，项目中又有许许多多的细节之处，就如同铸剑过程中的那每一个小小的研磨、花纹，铸剑需要打磨好多次，而做一个项目不也是需要不断的反复测试、修改么？那么如果一把剑已经打好了，在交付给剑客使用的时候，没怎么使用就断了，那么肯定第一想到的便是这个铸剑师不合格，不具有匠心。而我们在做一份项目，交付给很多人使用的过程中，发现体验不好，有很多的bug，那么用户首先想到的便是这个程序员不合格。\n\n陈阿金师傅在锻造一把需要当成国礼送给普金的剑时，剑身上需要刻画一百多个寿字，用到了之前没有用的技术，同时这种大的场合不能有丝毫的差错。可想而知，陈阿金师傅在锻造的过程中有多么大的压力，锻造这一把剑花费了8个多月时间。中途肯定经过了数不清的重头再来。我想陪伴到最后的必然是每一次失败后重重的叹息与咬牙重头再来。在大谈匠心的时候，确实它又很平凡，很简单。无非是每一次失败后的再来以及对超越现有的执着。为何珍贵？因为能坚持下去的人并不多，但更多的时候我们不得不坚持。\n\n再回到程序员这个行当，我们可能感觉，同别人相比，别人聪明、反应快，一天时间就做好了你需要两天才可以实现的功能，别人经验丰富，他对业务代码足够的熟悉、了解。但是，再聪明也离不开努力，否则必然会被淘汰。经验丰富的那位，相信以前也有当菜鸟的时候，也有为了赶项目没日没夜的加班熬夜。当你想到这儿，你就应该知道，其实每个人都一样，为了各种各样的目标，我们能够做的便是坚持，坚持脚下每一步路，坚持心中每一份坚持！", "tag": "杂记", "desc": "在大谈匠心的时候，确实它又很平凡，很简单。无非是每一次失败后的再来以及对超越现有的执着。", "tags": ["杂记"], "created_at": 1523027460, "updated_at": 1561620437, "created_by": 77641313, "id": "5d08ff4cf104995644ff3065", "acl": "未开放读, 创建者可写"}, {"title": "江南铜屋", "content": "非凡匠心第二季豆瓣影评8.9分，主要讲的是我们周边被我们所忽略的匠人匠心，尤其是在当今这个时代，当我们还在盲目推崇别国的精湛技艺的时候，殊不知，我们的周边一直有这样的一帮平凡人，他们有着非凡的匠心，一辈子将一件事做到了极致。\n\n豆瓣影评中记得有这样一段话：\n“这是个浮躁的时代，每个人都这样议论。快节奏的生活，几乎压的人喘不过气来。吃着外卖，看着泛娱乐化的节目，干着有一天没一天的工作。人们在大谈特谈匠人精神的时候，可曾有一瞬间想过那些就活在自己身边那些活生生的例子。拐角炸了一辈子油条的王大爷，街口修了三十年自行车的喻叔叔，写了一辈子对联的李伯伯······”\n\n其中有一期讲的是熔铜技艺，地点就在西子湖旁，河坊街江南铜屋。可能是因为三次经过，故而对这个地方印象深刻，在河坊街已变成一个商业化的街道时，江南铜屋倒是让我这样的人情有独钟。90后青年人，有着老年人的心态，对老物件情有独钟。突出表现在，每去一个城市，必然会先去当地的博物馆看看。看看这座城市的历史，将自己置身于那个时代，尤其是当看到水墨画或者是解放初期的照片时候，非常想穿越到那个时代，感受画中、照片中的情景。\n\n江南铜屋的创始人是朱炳仁和朱军岷父子二人，朱家铜在历经五代人艰苦卓绝的创新、研磨之后终于在今日发扬光大，中国90%的铜建筑几乎都是出自朱炳仁先生设计并完成。节目中提起他本人最引以为豪的一件作品便是雷峰塔，因为其中包含了大量的铜造品。父子二人潜心研究，在常州天宁寺宝塔被焚而受感悟，创新了熔铜技艺，将铜造技艺在中国乃至世界发扬光大。\n\n毋庸置疑，这是匠心的极致展现，将自己的事业坚持下去，并做到了极致。可能有人会说，因为我们从事的职业不同，在古老的行业可能更加能够展现匠心，就当今互联网的发展速度，在不远的将来你所从事的这个职业是否存在都是一个未知数？确实是这样，互联网的发展速度太快了，就从事的前端行业而言，几年之前，或许你会切页面、懂点jquery交互完全能够满足行业需求，但是到了如今，已远远不能够适应这个社会的需求。前端各大框架层出不穷，在我看来，现在的前端也可以说成是全栈，前端人员懂后台、懂框架已经成了标配。如果你还不知道这个现状，那么可能离淘汰也不远了。往往我们是被这个行业逼得不得不进步，领导随便打开一个移动端的应用质问你，为何别人家的这么流畅，你的卡成了狗。在我们找理由解释原因的时候，或许我们应该更多的审视审视自己，是否离淘汰不远了？当我们觉得舒服的时候，是否就是与同行拉开距离的时候？与传统行业相比，我们有很多的无奈，但是拥有一颗匠心对行业的赤诚之心，不管发展有多快，这些东西都永远不过时。\n\n匠心在我看来是一种精神的反映，在金钱至上的时代，我们所缺少的一种宝贵品质。\n\n书归正传，今日调休，闲来无事，于是又去了一趟铜屋，第三次去发现了前两次所未曾发现的精彩内容。虽然铜屋也是浓浓的商业气息，但至少它的作品独一无二。拍了一些照片，各位看官可做个鉴赏（图片放于七牛云，流量党请慎重观看！）\n\n![tongwu_01](http://img.wdcorner.cn/tongwu_01.JPG)\n![tongwu_02](http://img.wdcorner.cn/tongwu_02.JPG)\n![tongwu_03](http://img.wdcorner.cn/tongwu_03.JPG)\n![tongwu_04](http://img.wdcorner.cn/tongwu_04.JPG)\n![tongwu_05](http://img.wdcorner.cn/tongwu_05.JPG)\n![tongwu_06](http://img.wdcorner.cn/tongwu_06.JPG)\n![tongwu_07](http://img.wdcorner.cn/tongwu_07.JPG)\n![tongwu_08](http://img.wdcorner.cn/tongwu_08.JPG)\n![tongwu_09](http://img.wdcorner.cn/tongwu_09.JPG)\n![tongwu_10](http://img.wdcorner.cn/tongwu_10.JPG)\n![tongwu_11](http://img.wdcorner.cn/tongwu_11.JPG)\n![tongwu_12](http://img.wdcorner.cn/tongwu_12.JPG)\n![tongwu_13](http://img.wdcorner.cn/tongwu_13.JPG)\n![tongwu_14](http://img.wdcorner.cn/tongwu_14.JPG)\n![tongwu_15](http://img.wdcorner.cn/tongwu_15.JPG)\n![tongwu_16](http://img.wdcorner.cn/tongwu_16.JPG)\n![tongwu_17](http://img.wdcorner.cn/tongwu_17.JPG)\n![tongwu_18](http://img.wdcorner.cn/tongwu_18.JPG)", "tag": "杂记", "desc": "我们的周边一直有这样的一帮平凡人，他们有着非凡的匠心，一辈子将一件事做到了极致。", "tags": ["杂记"], "created_at": 1522203360, "updated_at": 1561620444, "created_by": 77641313, "id": "5d090078f104995666f69091", "acl": "未开放读, 创建者可写"}, {"title": "2017电影经典语录", "content": "![img](http://img.wdcorner.cn/p2960.jpg)\n\n就算你诚实，可生活一样在欺骗你。   ————《天才枪手》\n\n别让这些痛苦消失，也别丧失你感受到的快乐。————《请以你的名字呼唤我》\n\n欲要得到救赎，必先承受痛苦。————《看不见的客人》\n\n现在车有了，歌也有了，你倒没兴致了。————《相爱相亲》\n\n原来我们人生的本体生来就是破破烂烂，所以才会穷其一生不停地在缝缝补补。————《人生密密缝》\n\n死亡不是真的逝去，遗忘才是永恒的消亡。————《寻梦环游记》\n\n等你拿到这个角色，你必须要付出一切，全力以赴，这是你的梦想。————《爱乐之城》\n\n每个人心里都有一团火，路过的人只看到烟。————《至爱梵高·星空之谜》\n\n用权力得来的利益终究会被新的权力所没收。————《人民的名义》\n\n很多事情现在都不能做了，你们现在可能觉得这“不正常”，但时间会改变一切，这会成为新“正常”。————《使女的故事 第一季》\n\n灰心丧气会使人成长，但这只限年轻人！现在的我们需要的不是成长，而是结果。————《紧急救命3》\n\n敌人一直都胜券在握，但我们依旧奋战如初，这就是我所知道的全部意义。————《权力的游戏 第七季》\n\n你是我认识的最渣的混蛋，也是唯一让我感到有意义的同伴，我的人生需要你。————《马男波杰克 第四季》\n\n心一旦碎了，就会永远一直碎着。————《海边的曼彻斯特》\n\n一个始终不被善待的人，最能识别善良，也最珍惜善良。————《芳华》\n\n真正值得在乎的东西，不会越来越多，只会越来越少。————《怒》\n\n有时候白纸一张更能呈现无尽可能。————《帕特森》\n\n有时候如果你爱一个人，就要当一个陌生人。————《银翼杀手2049》\n\n你的超能力是什么？ - 有钱。————《正义联盟》\n\n我笔下的人物没法离开那里，而我却永远无法回去。————《杰出公民》\n\n我们所爱的人，是永远不能被替代的。————《弗兰兹》\n\n我想他们不会回来了。————《鬼魅浮生》\n\n尽管知道整个旅程，知道它通向哪里，我仍然倾心接受，欢迎它的每一个时刻。————《降临》 \n\n生如逆旅单行道，哪有岁月可回头，越往前走回头越难，于是乎永别。\n自欺欺人者会说无憾，心里其实明白的，没办法的办法才叫坦然。\n唯一能够做的，不过是尽早回头看一看，多看几眼。\n趁还来得及，趁还不算晚。\n趁故事尚在，趁人还没走远。\n\n其实这似曾相识的感觉，世上无数人曾的短暂拥有过吧，譬如你，比如我。\n可惜你我羞涩矜持，你我不敢惜缘，任凭小羽毛飘过眼前掠过指尖，也怯于伸手去捉弯腰去捡。故而，大多似曾相识的第一眼第二眼，大都终于插肩而过，止于雁渡寒潭。\n再奇妙的遇见，一个转身也就淡了。", "tag": "杂记", "desc": "别让这些痛苦消失，也别丧失你感受到的快乐。————《请以你的名字呼唤我》", "tags": ["杂记"], "created_at": 1516529820, "updated_at": 1561620451, "created_by": 77641313, "id": "5d09012ef10499569aff3252", "acl": "未开放读, 创建者可写"}, {"title": "关于奉壹杂记", "content": "### 名字来源\n\n源自《小石潭记》-柳宗元（崔氏二小生——恕己、奉壹）\n\n恕己，宽恕自己，也是纳悦自己，理解并接受真实的自己。\n\n奉壹，专注于一件事，一心如一，坚定自己的初心。\n\n奉壹杂记即为专注记录技术、生活、哲学、有趣的事儿和人~\n\n整个主题背景色选用类红色#e54d42，logo字体为居中的仿宋体，文艺情节和对未知事物的热情并存，拓展网络空间的一片小天地~\n\n### 奉壹杂记1.0.1版本现有页面及功能：\n\n文章列表页（文章标题、所属标签、描述、创建日期、分享、colorui构建主题风格色块、上拉加载、按时间倒序排序）\n\n文章详情页（文章内容、内容分享、查看大图、towxml处理markdown语法）\n\n后台用户表、文章表构建，数据接口调试\n\n### 奉壹杂记2.0.1版本实现功能：\n\n一级页面拆分文章列表及关于页面\n\n文章列表页数据加载优化、返回顶部\n\n详情页文章分享、小程序二维码生成、返回首页，文章更新时间，加载过渡动画\n\n![奉壹](http://imgs.wdcorner.cn/fenyi.jpg)", "tag": "杂记", "desc": "名字源自《小石潭记》-柳宗元（崔氏二小生——恕己、奉壹）奉壹：专注于一件事，一心如一", "tags": ["杂记"], "created_at": 1560922320, "updated_at": 1565677411, "created_by": 77641313, "id": "5d09c8f5a371df1cc824e453", "acl": "创建者可读, 创建者可写"}, {"title": " MVC以及MVVM MVP介绍", "content": "### 1. MVC\nModel-View-Controller(模型-视图-控制器)是最常见的软件架构之一，业界有着广泛应用。\n\n- 视图（View）：用户界面\n- 控制器（Controller）：业务逻辑\n- 模型（Model）：数据保存\n\n各部分之间的通信如下：\n\n![](https://gwemz.gitee.io/images/13-c871edca.png)\n\n1. View传送指令到Controller\n2. Controller完成业务之后要求Model改变状态\n3. Model将新的数据发送到View，用户得到反馈\n\n#### 接受用户指令时，MVC的两种方式：（互动模式）\n![](https://gwemz.gitee.io/images/13-807024f4.png)\n\n*另一种是直接通过Controller接受指令*\n\n![](https://gwemz.gitee.io/images/13-f18acc87.png)\n\n### 2. MVP\n**MVP模式将Controller改名为Presenter，同时改变了通信方向**\n\n![](https://gwemz.gitee.io/images/13-355c3d4d.png)\n\n1. 各部分之间的通信，都是双向的\n2. View与Model不发生联系，都是通过Presenter传递\n3. View非常薄，不部署任何业务逻辑，称为“被动视图”（Passive View）,即没有任何主动性，而Presenter非常厚，所有逻辑都部署在那里\n\n### 3. MVVM\n**MVVM模式将Presenter改名为ViewModel，基本上与MVP模式完全一致**\n\n![](https://gwemz.gitee.io/images/13-64e9b98a.png)\n\n唯一的区别是，它采用**双向数据绑定**（data-binding）:View的变动自动反映在ViewModel，反之亦然。Angular和Ember都采用这种模式", "tag": "技术", "desc": "Model-View-Controller(模型-视图-控制器)是最常见的软件架构之一，业界有着广泛应用", "tags": ["技术"], "created_at": 1491316800, "updated_at": 1561620488, "created_by": 77641313, "id": "5d10e0f9f14904793889d94e", "acl": "创建者可读, 创建者可写"}, {"title": "Cookie/LocalStorage/SessionStorage", "content": "“Cookie、LocalStorage、SessionStorage的区别？”这个问题成了被问到最多的问题，索性把它归归类，让自己的记忆更加深刻一点。\n## 基本概念\n### Cookie\nCookie是小甜饼的意思，顾名思义，它非常小，大小限制在4KB左右，是网景公司前雇员Lou Montulli在1993年3月被发明的。它的主要用途有保存登录信息，诸如在某一个网站的登录页面看到“记住密码”，这通常就是在Cookie中存入辨识用户身份的数据。\n### LocalStorage\nLocalStorage是HTMl5标准中新加入的技术，它并不是什么划时代的新东西，早在IE6时代就有相关技术userData，而当时由于考虑到浏览器的兼容性问题，故而没采用。如今，LocalStorage被大多数浏览器支持，故而炙手可热。\n\n| 特性 | Chrome     | Firefox     | Internet Explorer     | Opera     | Safari     |\n| :------------- | :------------- | :------------- | :------------- | :------------- | :------------- |\n| LocalStorage  | 4       | 3.5      | 8     | 10.5  | 4 |\n| sessionStorage  | 5       | 2      | 8     | 10.5  | 4 |\n### sessionStorage\nsessionStorage与LocalStorage接口类似，但数据保存的周期不同。sessionStorage将一部分数据在当前会话中保存下来，刷新页面数据依旧存在。但当页面关闭之后，sessionStorage中的数据就会被清空。\n## 三者的异同\n| 特性 | Cookie    | LocalStorage | sessionStorage |\n| :------------- | :------------- | :------------- | :------------- |\n| 数据的生命周期      | 一般由服务器生成 ，可设置失效时间。如果是在浏览器端生成Cookie，默认是关闭浏览器后失效     | 除非被清除，否则永久保存 | 仅在当前会话下有效，关闭页面或浏览器之后就会失效 |\n| 存放数据大小 | 4K左右 | 一般为5MB左右 | 一般为5MB左右 |\n| 与服务器端通信 | 每次都会携带到HTTP头中，如果使用Cookie保存过多数据，会带来性能问题 | 仅在客户端（浏览器）中保存，不参与和服务器的通信 | 仅在客户端（浏览器）中保存，不参与和服务器的通信 |\n| 易用性 | 需要程序员自己封装，原生的Cookie接口不友好 | 原生接口 |原生接口 |\n## 应用场景\nCookie一个常用的场景就是判断用户是否登录。LocalStorage接替了cookie管理购物车的工作，同时也会保存一些诸如HTML5游戏中产生的本地数据。sessionStorage适用于一些用户填写表单信息。\n## 安全性的考虑\n不是什么数据都适合放在 Cookie、localStorage 和 sessionStorage 中的。使用它们的时候，需要时刻注意是否有代码存在 XSS 注入的风险。因为只要打开控制台，你就随意修改它们的值，也就是说如果你的网站中有 XSS 的风险，它们就能对你的 localStorage 肆意妄为。所以千万不要用它们存储你系统中的敏感数据。\n", "tag": "技术", "desc": "Cookie LocalStorage与SessionStorage的区别", "tags": ["技术"], "created_at": 1501166700, "updated_at": 1561620479, "created_by": 77641313, "id": "5d10e235f14904793889ddd5", "acl": "创建者可读, 创建者可写"}, {"title": "网站SEO优化", "content": "这几天做的项目模块中涉及到了对公司网站的SEO优化，之前对网站的优化也一知半解，仅仅停留在使用合理化标签、减少代码的冗余量、网站标题、描述词优化这些基础水平。但在真实项目环境中，网站优化所涉及的内容很多，是一项足够考验耐力和细致的脑力劳动。\n## 什么是SEO？\n![seo](https://gwemz.gitee.io/images/seo.jpg)\n搜索引擎优化(Search Engine Optimization,简称SEO)是一种利用搜索引擎的搜索规则来提高有关目标网站在有关搜索引擎的排名方式。\n\n## 对搜索引擎不友好的网站有哪些特征：\n- 网页中大量采用图片或者 Flash 等富媒体（Rich Media）形式，没有可以检索的文本信息，而 SEO 最基本的就是文章 SEO 和图片 SEO；\n- 网页没有标题，或者标题中没有包含有效的关键词；\n- 网页正文中有效关键词比较少（一般小于整文章 2%~8%）；\n- 网站导航系统让搜索引擎“看不懂”；\n- 大量动态网页让搜索引擎无法检索；\n- 没有被其他已经被搜索引擎收录的网站提供的链接；\n- 网站中充斥大量欺骗搜索引擎的垃圾信息，如“过渡页”、“桥页”、颜色与背景色相同的文字；\n- 网站中缺少原创的内容，完全照搬硬抄别人的内容等。\n\n## 搜索引擎优化\n#### 内部优化\nMETA 标签优化：例如：TITLE，KEYWORDS，DESCRIPTION 等的优化\n内部链接的优化，包括相关性链接（Tag 标签），锚文本链接，各导航链接，及图片链接\n网站内容更新：每天保持站内的更新(主要是文章的更新等)\n#### 外部优化\n外部链接类别：博客、论坛、B2B、新闻、分类信息、贴吧、知道、百科、相关信息网等尽量保持链接的多样性\n外链运营：每天添加一定数量的外部链接，使关键词排名稳定提升。\n外链选择：与一些和你网站相关性比较高,整体质量比较好的网站交换友情链接,巩固稳定关键词排名\n\n## SEO优化步骤\n#### 关键词分析（也叫关键词定位）\n这是进行SEO优化最重要的一环，关键词分析包括：关键词关注量分析、竞争对手分析、关键词和网站相关性分析、关键词布置、关键词排名预测。\n#### 网站架构分析\n网站结构符合搜索引擎的爬虫喜好则有利于SEO优化。网站架构分析包括：剔除网站架构不良设计、实现树状目录结构、网站导航与链接优化。\n#### 网站目录与页面优化\nSEO不只是让网站首页在搜索引擎有好的排名，更重要的是让网站的每个页面都带来流量。\n#### 内容发布和链接设置\n搜索引擎喜欢有规律的网站内容更新，所以合理安排网站内容发布日程是SEO优化的重要技巧。链接布置会把整个网站有机地串联起来，让搜索引擎明白每个网页的重要性和关键词，实施的参考是第一点的关键词布置。友情链接战役也是这个时候展开。\n#### 与搜索引擎对话\n向各大搜索引擎登录入口提交尚未收录站点。在搜索引擎看SEO的效果，通过site:你的域名，知道站点的收录和更新情况。通过domain:你的域名或者link：你的域名，知道站点的反向链接情况。更好的实现与搜索引擎对话，建议采用Google网站管理员工具。\n#### 建立网站地图SiteMap\n根据自己的网站结构，制作网站地图，让你的网站对搜索引擎更加友好化。让搜索引擎能通过SiteMap就可以访问整个站点上的所有网页和栏目。\n最好有两套 siteMap,一套用户方便客户快速查找站点信息（html 格式），另一套方便搜索引擎得知网站的更新频率、更新时间、页面权重（xml 格式）。所建立的 sitemap 要和你网站的实际情况相符合。\n#### 高质量的友情链接\n建立高质量的友情链接，对于SEO优化来说，可以提高网站PR值以及网站的更新率，都是非常关键性的问题。\n#### 网站流量分析\n网站流量分析从 SEO 结果上指导下一步的 SEO 策略，同时对网站的用户体验优化也有指导意义。流量分析工具，建议采用分析工具 Google Analytics 分析工具和百度统计分析工具。\n\n [原文链接](http://wiki.jikexueyuan.com/project/seo/00.html)\n [参考文章](http://transbiz.com.tw/seo-guide/)", "tag": "SEO/技术", "desc": "搜索引擎优化是一种利用搜索引擎的搜索规则来提高有关目标网站在有关搜索引擎的排名方式", "tags": ["SEO", "技术"], "created_at": 1502975580, "updated_at": 1561620654, "created_by": 77641313, "id": "5d14680c22a18679d9ebea96", "acl": "创建者可读, 创建者可写"}, {"title": "小程序页面处理js逻辑", "content": "这一年又只剩了3个月左右，匆匆而逝。在和朋友聊天时也在谈论，这一年做了些什么？想想好像我的记忆都是跟着项目的版本号了，每个月至少一个版本的更新，从年初到现今，不知不觉，已经做了整整九个版本的小程序项目。从最初版本的几个简陋页面，到如今60多个页面的大小，几乎把网站核心功能都已经过了一遍，有的版本折磨的要死，有的版本飞快上线。\n\n对比前端正常开发和小程序开发，小程序有优势也有劣势，最大优势便是基于微信这个平台做开发，分享，插件兼容什么的几乎可以不用去考虑，几乎所有常用的业务公用模块都提供了相应的API，“上拉刷新、下拉加载、轮播、弹窗封装，日期组件、不同状态的加载效果处理等等”，诸如写个swiper轮播，在小程序内部可能10分钟搞定，包括点击展示图片弹层，基础样式处理，而且你压根不需要考虑滑动问题。而如果想要在wap端实现这个功能，我可能需要先找一个swiper插件，引用一堆css/js文件，然后函数调用，完了还需要再单独考虑这个图片弹层该怎么实现？因为swiper好像还不能直接把它写出来，就这样，一小时过去了。。。领导拿着狼牙棒在你旁边直勾勾盯着你看。而在我看来它的劣势也便是它的优势，所有的东西都封装好，没法做个性化开发。\n\n好了，言归正传，在之前八个版本的小程序开发时都或多或少遇到一个问题，页面中没法处理一些深入的业务逻辑，比如取整、时间戳转换日期、返回对象的JSON.parse处理，但是小程序页面wxml没有提供的一些方法。\n\n先聊聊之前的处理方式，诸如处理时间戳：（不推荐）\n\n外部引入时间日期处理公用JS\n```\n//时间日期处理方法（不详述）\n```\n\n当前页面JS文件\n```\nfetchData(){\n    wx.request({\n        url:'/ajax/test.json',\n        data:{\n\n        },\n        method: 'GET',\n        success:function(res){\n            if(res.data.message == 'success'){\n                let resList = res.data.resList;\n                for(let i in resList){\n                    resList[i].createTime = time.format(resList[i].createTime)\n                }\n                temp.setData({\n                    resList: resList\n                })\n            }\n        }\n    })\n}\n```\n这样处理其实问题很突出，需要在每次返回代码中额外加入一段遍历的操作，浪费性能，而且代码没法复用，下一个页面如果再遇到这样的问题，还需要重新再处理一番。\n\n小程序官方也对类似的问题提供了解决方案，只怪自己眼瞎，没看到。直到某一日看到一篇文章，才恍然大悟。\n\n`开发目录中可以创建.wxs后缀的文件，WXS（WeiXin Script）是小程序的一套脚本语言，结合 WXML，可以构建出页面的结构。`\n\n#### wxs基础概念\n\n```\n<wxs module=\"m1\">\nvar msg = \"hello world\";\n\nmodule.exports.message = msg;\n</wxs>\n\n<view> {{m1.message}} </view>\n```\n\n数据处理\n```\n// page.js\nPage({\n  data: {\n    array: [1, 2, 3, 4, 5, 1, 2, 3, 4]\n  }\n})\n```\n\n#### wxml中添加.wxs逻辑\n```\n//下面的 getMax 函数，接受一个数组，且返回数组中最大的元素的值\n<wxs module=\"m1\">\nvar getMax = function(array) {\n  var max = undefined;\n  for (var i = 0; i < array.length; ++i) {\n    max = max === undefined ? \n      array[i] : \n      (max >= array[i] ? max : array[i]);\n  }\n  return max;\n}\n\nmodule.exports.getMax = getMax;\n</wxs>\n\n//调用 wxs 里面的 getMax 函数，参数为 page.js 里面的 array\n<view> {{m1.getMax(array)}} </view>\n\n```\n\n#### wxml中引入.wxs文件\n//tools.wxs\n```\nvar filters = {\n  toFix: function (value) {\n    return value.toFixed(1)     //此处1为保留一位小数\n  }\n}\nmodule.exports = {\n  toFix: filters.toFix\n}\n```\n\n//wxml\n```\n<wxs module=\"filters\" src=\"../tools.wxs\"></wxs>\n\n<view class=\"box\">{{filters.toFix(item.value)}}</view>\n```\n\nOK，完美解决！再也不用去写重复的一堆恶心代码...\n\n#### 红点规则\n\n为 tabBar 某一项的右上角添加文本\n```\nwx.setTabBarBadge({\n  index: 0,\n  text: '1'\n})\n```\n\n移除taBar数量显示\n\n```\nwx.removeTabBarBadge({\n    index: 1,\n    success:function(){\n        \n    },\n    fail:function(){\n\n    },\n    complete:function(){\n\n    }\n})\n```\n\n红点处理思路：在列表页访问时，将该列表最大ID记录下来，保存到缓存中。在小程序启动时，app.js中的onLaunch函数，走一遍列表接口，获取到列表的最大ID，通过ID数值差来判断用户有多少条数据未读，从而展示到对应的tabBar上，列表更新后，把该消息移除。\n\n#### scroll-view无法横向滚动问题\n\n搞了快半小时，结果发现是scroll-view少加一个css属性，导致无法滑动。。。on shit~\n\n```\n.scroll-content{\n    white-space: nowrap;\n}\n```\n\n#### 数据未加载完成不展示页面结构\n\n```\nwxml:\n<view class=\"container\"  hidden=\"{{!loading}}\">\n\n<loading hidden=\"{{loading}}\">加载中...</loading>\n\nJS:\nPage({\n    data:{\n        loading: true\n    }\n})\n```\n", "tag": "小程序", "desc": "如何在小程序页面中引用js方法？", "tags": ["技术", "小程序"], "created_at": 1540905524, "updated_at": 1540905530, "created_by": 77641313, "id": "5d14749222a18607df1ebdec", "acl": "创建者可读, 创建者可写"}, {"title": "小程序字母导航", "content": "## 小程序字母导航\nwxml:\n\nscroll-into-view 滚动到页面中对应ID的位置\n```\n<scroll-view style=\"height:{{windowHeight}};\" scroll-into-view=\"{{alpha}}\">\n    <view class=\"item\" wx:for=\"{{keymap}}\" id=\"{{item}}\">\n\n    </view>\n</scroll-view>\n\n//字母表位置(catchtouchstart, catchtouchmove, catchtouchend 分别为滑动事件开始、移动和结束)\n<view data-id=\"selector\" catchtouchstart=\"handlerAlphaTap\" catchtouchmove=\"handlerMove\" catchtouchend=\"handlerEnd\" class=\"alphanet-selector\">\n    <view data-ap=\"{{item}}\" wx:for=\"{{keymap}}\" wx:key=\"unique\" class=\"selector-one\" wx:for-item=\"item\">\n        {{item}}\n    </view>\n</view>\n```\n\nJS：\n\n```\n//滑动开始\nhandlerAlphaTap(e) {\n    let { ap } = e.target.dataset;\n    this.setData({\n        alpha: ap,\n        touchStatus: true\n    });\n},\n\n//滑动过程\nhandlerMove(e) {\n    if(this.data.touchStatus){\n        if(this.timer){\n            clearTimeout(this.timer)\n        }\n        this.timer = setTimeout(() => {\n            let { keymap } = this.data;\n            let moveY = e.touches[0].clientY;\n            let rY = moveY - this.offsetTop;\n            if (rY >= 0) {\n                let index = Math.floor((rY - this.apHeight) / this.apHeight);\n                if (0 <= index && index < keymap.length) {\n                    let nonwAp = keymap[index]; \n                    wx.showToast({\n                        title:''+ nonwAp +'',\n                        icon:'none',\n                        duration: 500\n                    })\n                    nonwAp && this.setData({ alpha: nonwAp });\n                }\n            }\n        },16)\n    }\n},\n\n//滑动结束\nhandlerEnd() {\n    this.setData({\n        touchStatus: false\n    })\n}\n```\n\n## 小程序自定义多选功能\n\njs:\n```\nmoreSelect(){\n    let resultmap = this.data.resultmap;\n    //为数组添加自定义属性\n    for(let i in resultmap){\n        resultmap[i]['select'] = false;\n    }\n    this.setData({\n        resultmap: resultmap\n    })\n},\n\nselectItem(e){\n    let id = e.target.id;\n    this.data.resultmap[id].select = !this.data.resultmap[id].select;\n    this.setData({\n        resultmap: this.data.resultmap\n    })\n}\n```\n\n## 推荐博客 [莫昭的博客](https://www.yuque.com/shudan/blog)\n\n当事情来的时候，总会有应对之法的，仿佛并没有别人眼里看的那么坚韧、那么伟大。我们并没办法让命运停下来啊，除了冷静下来，寻求解决之法，其他的都没用。\n\n人生已经那么艰难了，总是要有些甜蜜之处的。\n\n一颗摇摆不定的芦苇，风吹过、季节淌过。凤永恒的吹，水比芦苇永恒的多，万事万物都没有留下痕迹。", "tag": "技术", "desc": "小程序中字母导航功能实现，滑动字母滚动到页面中对应ID的位置", "tags": ["技术", "小程序"], "created_at": 1535900100, "updated_at": 1561631738, "created_by": 77641313, "id": "5d149be96d0e610d9a468e27", "acl": "创建者可读, 创建者可写"}, {"title": "微信小程序开发总结", "content": "本文涉及的内容有：下拉刷新/上拉加载/检测滚动条滚动/三级品牌选择/微信授权登录/微信手机号授权登录/发送模板消息/微信支付/js复用/本地存储数组/刷新当前页面 and some problems\n\n#### 下拉刷新\n\n`方式一`\n\n```\napp.json(全局)\n\n\"window\":{\n    \"enablePullDownRefresh\": true\n}\n\npage.json(当前页面)\n\n{\n    \"enablePullDownRefresh\": true\n}\n\n//下拉逻辑(Page)\nonPullDownRefresh:function(e){\n\n}\n```\n\n`方式二`\n```\n<scroll-view bindscrolltoupper=\"refresh\" bindscrolltolower=\"loadmore\" scroll-y=\"true\"></scroll-view>\n\nbindscrolltoupper 滚动到顶部/左边\n```\n\n#### 上拉加载\n\n`方式一`\n```\n//滚动条到最底部执行(Page)\nonReachBottom:function(){\n\n}\n```\n`方式二`\n```\n<scroll-view bindscrolltoupper=\"refresh\" bindscrolltolower=\"loadmore\" scroll-y=\"true\"></scroll-view>\n\nbindscrolltolower 滚动到底部/右边\n```\n\n#### 检测滚动条滚动\n```\n//检测滚动条滚动事件\nonPageScroll:function(){\n\n}\n\n//回到页面顶部\ngotop:function(){\n    wx.pageScrollTo({\n      scrollTop: 0,\n      duration: 400\n    });\n}\n```\n\n#### 关于三级品牌选择\n\n'三级品牌'?'弹窗':'单独页面'\n\n优点：单独页面(简化单个页面代码量、代码复用、用户体验)\n\n不同页面数据通信 setStorage  or  setData\n\n`setStorage`\n```\n单独页面js:\nwx.setStorageSync('onebrandid', pids);\nwx.setStorageSync('onebrand',brand);\nwx.setStorageSync('brandpic',pic);\n\n原页面:\nonShow:function(){\n    let cartype = wx.getStorageSync('onebrandid');\n    let bigType = wx.getStorageSync('onebrand');\n    let parSerial = wx.getStorageSync('brandpic');\n}\n\n清除本地缓存带来影响\ndelstorage: function () {\n    let arr = ['onebrandid', 'onebrand', 'brandpic'];\n    for (let i in arr) {\n        wx.removeStorageSync(arr[i]);\n    }\n}\n```\n`setData`\n```\ngoBack:function(){\n    let pages = getCurrentPages();//当前页面\n    let prevPage = pages[pages.length - 2];//上一页面\n    prevPage.setData({//直接给上移页面赋值\n        onebrandid:price,      \n        onebrand:name,    \n        brandpic:id\n    });\n    wx.navigateBack({\n        delta: 1\n    })\n}\n```\n\n`返回原页面`\n```\n// 跳回到选择页面(消除返回箭头带来的影响)\nwx.navigateBack({\n    delta: 3\n})\n```\n\n#### 微信授权登录\n\n```\nwxml:\nbutton open-type=\"getUserInfo\" plain=\"true\" bindgetuserinfo=\"bindGetUserInfo\"\napp.js -> code\njs:\nbindGetUserInfo:function(){\n    //用户同意授权\n    if (e.detail.errMsg == 'getUserInfo:ok'){\n        // 判断sessionKey是否失效(AppID  + AppSecret) access_token -> 用于获取用户唯一表示openid -> 发送模板消息\n        wx.checkSession({\n            success: function (res) {\n                wx.getUserInfo({\n                    success: function (res) {\n                    that.saveUserInfo(res.encryptedData, res.iv, code)\n                    }\n                })\n            },\n            fail: function () {\n                wx.login({\n                    success: function (res) {\n                    let code = res.code;\n                    wx.getUserInfo({\n                        success: function (res) {\n                            that.saveUserInfo(res.encryptedData, res.iv, code)\n                        }\n                    })\n                    }\n                })\n            }\n        })\n    }\n}\n//解密保存用户信息\nsaveUserInfo:function(){\n\n}\n```\n\n#### 微信授权手机号登录\n\n```\nwxml:\n\n<button open-type=\"getPhoneNumber\" bindgetphonenumber=\"getPhoneNumber\" plain=\"true\">\n\njs:\ngetPhoneNumber:function(){\n    if (res.detail.errMsg == 'getPhoneNumber:ok') {\n        let encryptedData = res.detail.encryptedData;\n        let iv = res.detail.iv;\n        wx.login({\n            success: function (res) {\n                // success\n                let code = res.code;\n                that.userphoneNum(encryptedData, iv, code)\n            }\n        })\n    }\n}\n//解密用户手机号\nuserphoneNum:function(){\n\n}\n```\n\n#### 发送模板消息\n前置条件（用户已完成授权操作）\n`方式一(表单)`\n\n```\n//表单(用于生成fomId) 真机环境测试\n<form report-submit=\"true\" class=\"right\" bindsubmit=\"formSubmit\">\n    <button bindtap=\"inquiry\" form-type=\"submit\" plain=\"true\">发送模板消息</button>\n</form>\n\n// 获取formId\nformSubmit: function (e) {\n    let formid = e.detail.formId;\n}\n\n//后台模板配置\n```\n`方式二(prepay_id)`\n\n支付完成之后可发送\n\n#### 微信支付\n```\n// 登录获取code\n\nwx.login({\n    success: function (res) {\n        var code = res.code;\n        // 获取支付需要的参数\n        wx.request({\n            url: weixinUrl,\n            data: {\n                childtype: 'leixin',\n                loginName: mobile,\n                money: price,\n                rechargetype: 1,\n                code: code\n            },\n            method: 'GET', // OPTIONS, GET, HEAD, POST, PUT, DELETE, TRACE, CONNECT\n            header: {\n                'from': 'miniprogram'\n            }, // 设置请求的 header\n            success: function (res) {\n                // success\n                var data = JSON.parse(res.data);\n                // 支付步骤\n                wx.requestPayment({\n                    'timeStamp': data.timeStamp,\n                    'nonceStr': data.nonceStr,\n                    'package': data.package,\n                    'signType': data.signType,\n                    'paySign': data.paySign,\n                    'success': function (res) {\n                        wx.showToast({\n                            title: '支付成功'\n                        })\n                    }\n                })\n            }\n        })\n    }\n})\n```\n\n#### 手机验证码登录\n```\nlogin.js:\n\nfunction aa(){\n\n}\nfunction bb(){\n\n}\nmodule.exports = {\n    A: aa,\n    B: bb\n}\n\npage.js\nimport login from '../../utils/login';\n\n/* 登录方法获取 */\nfor (let key in login) {\n    temp[key] = login[key]\n}\n```\n\n#### 本地存储数组\n```\n数组、对象、字符串\n/*异步*/\nwx.setStorage({\n  key:\"value\",\n  data:\"data\"\n})\n/*同步*/\nwx.setStorageSync('value','data');\n```\n\n#### 刷新当前页面\n\nthat.onShow() 在onshow函数中执行获取相关数据的操作\n\n#### 华为手机中文传参乱码\n部分设备中文传参乱码，导致无法获取正确数据，解决方法：encodeURI() 将字符串作为URI进行编码\n`encodeURI(this.data.serial)`\n\n#### problems\niphonex 适配\n授权登录不同版本微信表现不一致\n部分设备加载慢\n滑动体验问题", "tag": "技术", "desc": "本文涉及的内容有：下拉刷新/上拉加载/检测滚动条滚动/三级品牌选择/微信授权登录/手机号授权登录/发送模板消息", "tags": ["技术", "小程序"], "created_at": 1527257874, "updated_at": 1527258055, "created_by": 77641313, "id": "5d149d266d0e61407f4698ac", "acl": "创建者可读, 创建者可写"}, {"title": "网络现状-性能优化", "content": "#### 背景\n\n互联网正在呈爆发式的增长，我们创建的web平台也是如此。我们通常没有考虑到用户网络的连通性和使用背景。我们还没有建立起同理心和对形式变化的认知，更不用说对性能的考虑。\n\n现今网络状况现状：\n\n地球上74亿人口中，只有46%的人能够上网，平均网络速度为7Mb/s。更重要的是93%的互联网用户都是通过移动设备上网的——不去迎合手持设备是不可原谅的。数据往往比我们想象的昂贵的多——购买 500MB 数据的价格在德国要为此工作 1 个小时，而在巴西需要 13 个小时。\n\n我们的网站表现的也不尽如人意——平均体积大约是第一版Doom游戏的大小(3MB左右)。图片可以轻松占用1.7MB，而javascript平均为400KB。不仅仅只有web平台，本地应用程序也有同样的问题，如为了修复某些bug，不得不下载200MB的应用。\n\n技术人员经常会发现自己处于特权地位。拥有新型高端的笔记本、手机和快速的网络连接。我们很容易忘记，其实并不是每个人都有这样的条件（实际上只有少部分人而已）。\n\n> 如果我们只站在自己而不是用户的角度来构建 web 平台，那这将导致糟糕的用户体验。\n\n我们如何通过在设计和开发中考虑性能来做得更好呢？\n\n#### 资源优化\n最能明显提升性能但未被充分利用的方式是，从了解浏览器如何分析和处理资源开始。事实证明，当浏览器解析和立即确定资源的优先级时，在资源发现方面表现得非常不错。\n\n> 如果请求包含用户视口渲染所需的资源，那该请求就是关键请求。\n\n对于大多数网站，关键请求可以是 HTML、必要的 CSS、LOGO、网络字体，也可能是图片。事实证明，在大多数情况下，当资源被请求时，许多其他不相关的（JavaScript、追踪代码、广告等）也被请求了。不过我们能够通过仔细挑选重要资源，并调整它们的优先级来避免这种情况发生。\n\n通过`<link rel ='preload'>`,我们可以手动强制设置资源的优先级，来确保所期望的内容按时渲染。这种技术可以明显改善“交互时间”指标，从而使最佳用户体验成为可能。\n\n` <link rel ='preload' href=\"sytle.css\" as=\"style\">`\n\n通用性能清单：\n\n* 主动缓存\n* 启用压缩\n* 优先关键资源\n* 使用 CDN\n\n#### 图片优化\n页面传输的大部分数据通常都是图片，因此优化图片可以带来很大的性能提升。有许多现有的策略和工具可以帮助我们删除多余的字节，但首先要问的是：“图片对于传达后续的信息和效果至关重要吗？”。如果可以移除，不仅可以节省带宽，还可以减少请求。\n\n在某些情况下，我们可以通过不同的技术来实现同样的效果。CSS 有很多具有艺术性的属性，例如阴影、渐变、动画和形状，这就允许我们用具有合适样式的 DOM 元素来替代图片。\n\n**选择正确的格式**\n\n如果必须使用图片，那确定哪种格式比较合适是很重要的。一般都在矢量图和栅格图之间进行选择：\n\n* 矢量图形：与分辨率无关，文件通常比较小。特别适用于 LOGO、图标和由简单图形（点、线、圆和多边形）组成的图片。\n* 栅格图像：表现内容更丰富。适用于照片。\n\n做出上面的决定后，有这样的几种格式供我们选择：JPEG、GIF、PNG-8、PNG-24 或者最新的格式，例如 WEBP 或 JPEG-XR。既然有这么多的选择，那如何确保我们选择的正确性呢？以下是找到最佳格式的基本方法：\n\n- JPEG：色彩丰富的图片（例如照片）\n- PNG–8：色彩不是很丰富的图片\n- PNG–24：具有部分透明度的图片\n- GIF：动画图片\n\n**尝试新格式**\n有这样几种由浏览器厂商开发的新图片格式：Google 的 WebP，Apple 的 JPEG 2000 和 Microsoft 的 JPEG-XR。\n\nWebP是最具有竞争力的，支持无损和有损压缩使得它被广泛应用。无损 WebP 比 PNG 小 26%，比 JPG 小 25-34%。74% 的浏览器支持率及降级方案使它可以安全地被使用，最多可节省 1/3 的传输字节。JPG 和 PNG 可以通过 Photoshop 和其他图像处理程序，也可以使用命令行（brew install webp）将其转换为 WebP。\n\n**使用工具和算法进行优化**\n即便使用了高效的图片格式也需要后续的处理和优化。这一步很重要。\n\n如果你选择了体积相对较小的 SVG，它们也需要被压缩。SVGO 是一个命令行工具，可以通过剥离不必要的元数据来快速优化 SVG。另外，如果你喜欢 Web 界面或者由于操作系统的限制，也可以使用 Jake Archibald 的 SVGOMG。由于 SVG 是基于 XML 的格式，所以它也可以被服务端 GZIP 压缩。\n\nImageOptim 是大多数其他图片格式的绝佳选择，它将 pngcrush、pngquant、MozJPEG、Google Zopfli 等一些不错的工具打包进了一个综合的开源包里面。作为一个 Mac OS 应用程序、命令行界面和 Sketch 插件，ImageOptim 可以轻松地用于现有的工作流中。大多数 ImageOptim 依赖 CLI 都可以在 Linux 或者 Windows 平台上使用。\n\n选择工具时，请确保它们能达到预期并适合团队的工作流。最好能自动化优化，这样所有图片都是优化过了的。\n\n**响应式图片**\n十年前，也许一种分辨率就能满足所有的场景，但随着时代的变化，响应式网站现今已截然不同。这就是为什么我们必须特别小心地实施我们精心优化的视觉资源，并确保它们适应各种视口和设备。幸运的是，感谢响应式图像社区组织，通过 picture 元素和 srcset 属性（都有 85%+ 的浏览器支持率），我们可以完美地做到。\n\n**srcset 属性**\nsrcset 在分辨率切换场景中表现得非常不错 —— 当我们想根据用户的屏幕密度和大小显示图片时。根据 srcset 和 sizes 属性中一些预定义的规则，浏览器将会根据视口选择最佳的图片进行展示。这种技术可以节省带宽和减少请求，特别是对于移动端用户。\n\n```\n<img srcset=\"cat-320w.jpg 320w,\n             cat-480w.jpg 480w,\n             cat-800w.jpg 800w\n     size=\"(max-width:320px) 100vw,\n           (max-width:480px) 80vw,\n           800px\"\n     src=\"cat-800w.jpg\" alt=\"Cat\">\n```\n\n**picture 元素**\npicture 元素和 media 属性旨在更容易地通往艺术殿堂。通过为不同的条件提供不同的来源（通过 media-queries 测试），无论分辨率如何，我们始终能聚焦在最重要的图像元素上。\n\n```\n<picture>\n    <source media=\"(min-width:40em)\"\n            srcset=\"big.jpg 1px, big-hd.jpg 2x\">\n    <source srcset=\"small.jpg 1px, small-hd.jpg 2x\">\n    <img src=\"fallback.jpg\" alt=\"\">\n</picture>\n```\n**使用图片 CDN**\n图片性能的最后一步就是分发了。所有资源都可以从使用 CDN 中受益，但有一些特定的工具是专门针对图片的，例如 Cloudinary 或者 imgx。使用这些服务的好处远不止于减少服务器流量，它还可以显著减少响应延迟。\n\nCDN 可以降低重图片站点提供自适应和高性能图片的复杂度。他们提供的服务各不相同（价格也不同），但是大多数都可以根据设备和浏览器进行尺寸调整、裁剪和确定最合适的格式，甚至更多 —— 压缩、检测像素密度、水印、人脸识别和允许后期处理。借助这些强大的功能和能够将参数附到 URL 中，使得提供以用户为中心的图片变得轻而易举了。\n\n**图片性能清单**\n* 选择正确的格式\n* 尽可能使用矢量图\n* 如果变化不明显，则降低质量\n* 尝试新格式\n* 使用工具和算法进行优化\n* 学习 srcset 属性和 picture 元素\n* 使用图片 CDN\n\n#### 优化网络字体", "tag": "技术", "desc": "互联网正在呈爆发式的增长，我们创建的web平台也是如此。我们通常没有考虑到用户网络的连通性和使用背景", "tags": ["技术"], "created_at": 1520259867, "updated_at": 1520259927, "created_by": 77641313, "id": "5d149e606d0e617ee446846a", "acl": "创建者可读, 创建者可写"}, {"title": "JS常用方法", "content": "## 前言\n看过不少技术博客文章，总能看到一句话，输出便是最好的输入。要想更好的掌握一门语言，要学会不断地去输出东西，这样才会增加更多的记忆点。当然这个过程可能比较耗费时间。\n\n既然标签是javascript，那我就顺带提提这门语言，由最初的一门脚本语言，但现在越来越多领域应用到了它，未来可能一个应用全部由javascript构建完成。很多人疯狂的游走于各个语言的学习之中，但是否真正掌握了一门语言？听过一句话，如果连一门语言也写不好的话，那么其他语言你一定写不好，我们在拓展广度的同时是否真正对它进行了深度的扩展？\n\n## 正文\n#### JavaScript数据强制转换\n* `Number()`   转换成数值类型\n* `String()`   转换成字符串类型\n* `Boolean()`  转换成布尔类型\n* `parseInt()` 将字符型转换为整形\n* `parseFloat()`  转换为浮点型\n\n#### JavaScript数组对象\n* `arr.push(数组元素...)`  向数组的末尾添加新的元素，返回值是新数组的长度。可以一次添加多个元素。\n* `arr.unshift(数组元素...)`  向数组的开头添加新的元素，返回值是新数组的长度。可以一次添加多个元素。\n* `arr.pop()`  删除数组的最后一个元素，返回删除的元素。\n* `arr.shift()`  删除数组的第一个元素，返回删除的元素。\n* `arr.splice(index,数量,添加的元素...)`  index：从何处开始添加/删除   数量：规定删除的个数，如果是0，则不删除  需要添加的元素，可以当做替换的元素  若从arr中删除了元素，则返回的是含有被删除元素的数组。\n* `arr.split()`   字符串分割为数组\n* `arr.join([分隔符])`  把数组元素按照指定分隔符组合成一个字符串，如果没有指定分隔符，默认是用','\n* `arr.slice()`  从截取指定的开始位置，到结束位置(不包括)的元素。如果不指定结束位置，则从指定的开始位置截取到结尾。 支持负数(-1)，返回新数组。\n* `arr.concat()`  数组的连接，连接两个或更多的数组，并返回新数组，但是对原数组没有任何影响。\n* `arr.sort(fun)`  数组的排序，默认是按照字符编码的顺序进行排序。如果要实现其它排序规则，则要传入一个参数。(a<b,a>b,a=b) 后续研究下\n\n#### JavaScript字符串对象\n* `str.charAt(num)`  返回在指定位置的字符\n* `str.charCodeAt(num)`   返回指定位置字符的Unicode编码\n* `str.fromCharCode()`  接收一个或多个指定的Unicode值，然后返回一个或多个字符串(var n = String.fromCharCode(99);)\n* `str.indexOf(\"\")`   返回某个指定字符串，在字符串中首次出现的位置\n* `str.lastIndexOf(\"\")`  返回指定的字符串最后出现的位置\n* `str.match()`  在字符串中检索指定的值，返回的值就是指定的值\n* `str.search()`  只能用于正则\n* `str.replace()`  将字符串中的一些字符替换为另外一些字符。\n* `str.slice()`   从指定的开始位置，到结束位置(不包括)的所有字符串。如果不指定结束位置，则从指定的开始位置，取到结尾。slice参数可以是负数\n* `str.substring(start,end)`   从指定的开始位置，到结束位置(不包括)的所有字符串。如果不指定结束位置，则从 指定的开始位置，取到结尾\n* `str.substr(start,length)`   从指定的位置开始取指定长度的字符串。如果没有指定长度，从指定开始的位置取到结尾。\n* `str.split(\"分割位置\",[指定的长度])`  将一个字符串分割成数组\n* `str.toLowerCase()`    用于把字符串转换为小写\n* `str.toUpperCase()`    用于把字符串换位大写\n\n#### JavaScript　Math对象\n\n\n## 结尾\n很多方法比较常用，但是在学的时候并没有太多感触，所以，应用是最好的学习方式。\n未完待续...\n", "tag": "技术", "desc": "JavaScript数据强制转换、数组对象、字符串对象、Math对象", "tags": ["技术"], "created_at": 1514032048, "updated_at": 1514032292, "created_by": 77641313, "id": "5d149f736d0e6103b9d32ddb", "acl": "创建者可读, 创建者可写"}, {"title": " VH和VW实现流体排版", "content": "## 前言\n不像响应式布局，通过media query，设置几个变化点来适配，流体排版通过调整大小，适配所有设备宽度。这个方法可以使我们开发的网页，在几乎所有屏幕尺寸上都可以使用。但出于一些原因，它的使用率还远远没有响应式技术高。\n\n## 流体排版\n`视口（viewport）单位`,使流体排版在页面上应用变为可能。视口单位是根据浏览器的视口尺寸的百分比来定义的。\n\n举个例子，1视口宽度（vw）等于视口宽度的1%，它不同于百分比的地方是，它的宽度是依赖于视口的宽度的，而百分比是元素的祖先元素来决定的。\n\n视口单位，不同于其它单位，它不依赖于基础字体的大小。这种差别很重要，使它变得有意义而且独特。\n\n**可以使用的4种视口单位：**\n* vw:视口宽度(viewport width)\n* vh:视口高度(viewport height)\n* vmin:视口宽度或高度，选择小的那个\n* vmax:视口宽度或高度，选择大的那个\n\n使用流体排版最简单的方法，是把html元素的font-size，设置为一个流体单位：\n\n```\nhtml{font-size:2vw;}\n```\n\n这个例子中，我们把根元素的字体大小设置为2vw。这里我们已经修改了根元素字体大小。因为直接或间接使用的em或rem单位，都是依赖于\"root rem\"的，所以也变成流体的了。例如\n\n```\nh1{  font-size:2em; }\n```\n\nh1的font-size:2em，如果它依赖的是根节点的字体大小，那么 font-size:2*2vw=4vw。\n\n**只使用视口相关的单位也有一些不足。**\n* 无法精确地控制放大比率。\n* 没有最大或最小字体大小。\n* 和使用font-size相比，用户更容易使用像素来声明大小。\n\n## 控制视口单位来设置最小最大font-size\n\nhtml设置为font-size:2vw的方法，看起来既是流体的，调用起来也很方便，但有些场景没法覆盖。视口单位不是万能的，它也需要使用一些其它的方法，来解决无法覆盖的场景。由于视口单位都是依赖于视口的，在非常小的屏幕上，会得到很小的字体大小，已致无法查看。（chrome的最小字体是12px，好像可以解决了。）\n\n理想情况下，我们可以通过设置最小字体来避免这种情况，但CSS中没有min-font-size这个属性。通过一些横向思维，我们可以得到实现这种效果的方法。\n\n首先，我们可以使用calc()表达式。\n\n```\nhtml{ font-size: calc(1em + 1vw); }\n```\n这样就算我们在一个0宽度的视口中，font-size的大小也会存在，并为1em。在大的屏幕上，1vw也会在最小字体1em的基础上增加。但是这种解决方法也不是最理想的。通常我们只是想在一些小的屏幕上去设置最小字体。我们可以使用media query来解决：\n\n```\n@media screen and (min-width: 50em) {\n  html {\n    font-size: 2vw;\n}}\n```\n上面代码设置，是仅在当视口宽度大于50em的时候，使用流体。虽然这样能很好的工作，但也表明会在固定值和流体值之间跳动。为了解决这个问题，我们可以计算出流体值和固定值之间的对应关系。\n\n如果默认字体大小是16像素，并且2vw是2%的视口宽度，那么可以知道在800像素的视口时两个值是相等的。（16/(2/100)=800）\n\n因为我们想在media query中，使用em单位来匹配。现在来换算一下像素到em。800像素除以16(1em = 16px)：800/16=50。我们也可以使用这个公式来算1/(2/100)=50。和上面例子里使用的变化条件一样，2vw对应的是50em。最终，我们得到了一个不会在固定和流体之间，产生跳动变化的值。\n\n同样的可以用公式去算出最大字体。如果我们想使用的最大字体是24像素，那么对应的视口宽度就是24/(2/100)=1200px。换算成字体，就是1.5/(2/100)=75em。如果视口宽度大于75em时，我们就把字体大小设置成固定值。\n\n```\n@media screen and (min-width: 75em) {\n  html {\n    font-size: 1.5em;\n  }}\n```\n这些计算都不是太难，下面做了一个表格，显示了各视口宽度，流体大小对应的字体大小。\n\n![](/images/10-22-1.png)\n\n通过这个表格，你可以获得一些控制视口单位变化。使用单独的视口单位，可以只看对应的一列中的字体大小。\n\n## 控制缩放比率\n在不使用media query的情况下，我们不可能解决，在400像素的屏幕上显示16像素的字体，在800像素显示24像素的问题。\n\n还有，你可能会说，可以使用设置最大最小字体的方式，来解决这个问题。但这里不是像那样来处理的。\n\n我们要怎么去解决这个问题呢？答案是使用calc()。使用calc和视口单位配合，我们可以用高级的流体排版，可以精确地控制一定范围内的视口宽度使用特定大小的像素值。这里需要建立一个基本的数字函数：\n\n![](/images/10-22-2.png)\n\n## 保持理想的阅读长度\n在《The elements of typographic style》,Robert Bringhurst 提出一个合理的阅读长度 大约是45到75个字符的长度\n\n同样的规则可以直接运用到流体排版上，很多情况下，文件缩放实现一致的阅读长度是可能的。\n\n在响应式方法里，我们在media query里设置不同的字体大小，调整容器的宽度，来保持正确的阅读长度。然而，使用流体排版，调整media query下的值方法已经行不通了。 只是设置容器的大小，使它的比率和字体相同。我们可以使用像上文提到的计算font-size的方法，使用 calc（）来计算width属性的值。这可以保持阅读长度-而且样式表也更容易阅读和维护了。\n\n在非常小的屏幕维护理想的阅读长度是不可能的。这种情况下，我们选择把容器的宽度设置为智能移动设备的宽度。\n\n## 使用流体排版\n如果要使用流体排版，要先想清楚要使用哪种解决方案。\n\n如果整个设计都是流体的，可以考虑使用rem来定义流体，可以声明html字体大小为一个流体单位。可以使用em和rem来定义所有设计部分。\n\n小心选择你的最大最小字体。关于这点，你需要决定是否直接使用视口单位或对更加精确地缩放比率。如果是后者，使用Sass,LESS或PostCSS插件中的函数，可以更简单实现。\n\n确保获得了正确的字体的最大最小值。这是问题的关键。一旦你选定了根元素的字体大小，其它的所有组件都是依赖这个值来计算的。项目中如果后面要调整这个值，那么整个项目都要调整。\n\n不要忘记，在使用流体排版之前定义一个默认的字体大小。默认字体大小，用来在那些不支持流体字体大小的浏览器上使用的，这个值不需要和字体最小值 相同。\n", "tag": "技术", "desc": "不像响应式布局，通过media query，设置几个变化点来适配，流体排版通过调整大小，适配所有设备宽度", "tags": ["技术", "CSS"], "created_at": 1508682060, "updated_at": 1561632875, "created_by": 77641313, "id": "5d14a03d6d0e617ee1d33017", "acl": "创建者可读, 创建者可写"}, {"title": "什么是内存泄漏?", "content": "## 前言\n\n在项目评审阶段，产品提出了需要做A、B测试？What?什么是A、B测试，好吧，其实就是一个功能的两种不同版本，需求是希望用户能够随机的切换两种不同版本，进而对不同版本的数据做统计。于是考虑再三之后选择了通过cookie来实现两种不同版本的切换，实现思路：判断客户端是否存在对应类型的cookie，若存在，则通过存在类型的cookie值来显示相应的版本，若不存在，则随机生成一个cookie:\n\n```\nif($.cookie('class')){\n\n}else{\n  if(Math.random()<0.5){\n         $.cookie('class','A');\n     }else{\n        $.cookie('class','B');\n     }\n  }\n\nif($.cookie('class') == 'A'){\n   展示A版本信息\n}else{\n   展示B版本信息\n}\n```\n紧接着，有一个需求是希望能够实现PC和移动端拖拽进度条的功能(PC端需要兼容到IE7)，我们所知道PC端鼠标拖拽用到了`onmousedown`、`onmousemove`和`onmouseup`事件，而移动端显然无法用相同的事件，最后选择了利用Html5的触摸事件，`ontouchstart`、`ontouchmove`、`ontouchend`，`PC`和`WAP`端的实现思路：\n```\nPC 端：\nvar scale = function (btn,bar,title){\n    this.btn=document.getElementById(btn);\n    this.bar=document.getElementById(bar);\n    this.title=document.getElementById(title);\n    this.step=this.bar.getElementsByTagName(\"div\")[0];\n    this.init();\n};\nscale.prototype={\n    init:function (){\n        var f=this,g=document,b=window,m=Math;\n        f.btn.onmousedown=function (e){\n            var x=(e||b.event).clientX;\n            var l=this.offsetLeft;\n            var max=f.bar.offsetWidth-this.offsetWidth;\n            g.onmousemove=function (e){\n                var thisX=(e||b.event).clientX;\n                var to=m.min(max,m.max(0,l+(thisX-x)));\n                f.btn.style.left=to+'px';\n                f.ondrag(m.round(m.max(0,to/max)*100),to);\n                b.getSelection ? b.getSelection().removeAllRanges() : g.selection.empty();\n            };\n            g.onmouseup=new Function('this.onmousemove=null');\n        };\n    },\n    ondrag:function (pos,x){\n        this.step.style.width=(Math.max(0,x)+15)+'px';\n        this.title.innerHTML=pos+'%';\n    }\n}\nnew scale('btn','progress','title');\n\nWap端：\nvar start,end,s,btn1_width;\nbtn1_width = $('.btn1').width()/2;\n$('.btn1').on('touchstart', function (e) {\n    var start = parseInt(e.originalEvent.changedTouches[0].pageX);\n    s = parseInt($(this).css(\"left\"));\n    $(document).on(\"touchmove\", function (e) {\n        end = parseInt(e.originalEvent.changedTouches[0].pageX);\n        var width = $('.progress1').width();\n        var move = end - start;\n        localStorage.progress = s + move;\n        if ((s + move) > 0 && (s + move) < width) {\n            $('.btn1').css({left: s + move  + \"px\"});\n            $(\".pro_act1\").css({width: s + move + btn1_width + 'px'});\n        }\n    })\n})\n\n$(\".btn1\").on(\"touchend\", function (e) {\n    $(this).off(\"touchmove\");\n});\n```\n当然，实现这样的业务代码，无论如何都有前人的方法可以去借鉴，那么在开发过程中，其实比起业务逻辑更为麻烦的事我认为是在前人的基础上做开发，不知不觉就码出了新的bug，因为你所修改的内容有些深层次的含义你没办法面面俱到的都想到，不知不觉就制造出了新的bug，然后就开始了改bug的'美好时光'......\n\n## 正文\n书归正传，什么是内存泄漏？我们该如何解决内存泄漏？这个在我们码代码的过程中可能不知不觉就会产生的问题？\n\n### 什么是内存泄漏？\n程序的运行需要内存。只要程序提出要求，操作系统或者运行时（runtime）就必须供给内存。\n\n对于持续运行的服务进程（daemon），必须及时释放不再用到的内存。否则，内存占用越来越高，轻则影响系统性能，重则导致进程崩溃。\n\n![](http://www.ruanyifeng.com/blogimg/asset/2017/bg2017041701-1.png)\n\n不再用到的内存，没有及时释放，就叫做内存泄漏（memory leak）。\n\n大多数语言提供自动内存管理，减轻程序员的负担，这被称为\"垃圾回收机制\"（garbage collector）\n\n### 垃圾回收机制\n垃圾回收机制怎么知道，哪些内存不再需要呢？\n\n最常使用的方法叫做\"引用计数\"（reference counting）：语言引擎有一张\"引用表\"，保存了内存里面所有的资源（通常是各种值）的引用次数。如果一个值的引用次数是0，就表示这个值不再用到了，因此可以将这块内存释放。\n\n![](http://www.ruanyifeng.com/blogimg/asset/2017/bg2017041703.png)\n\n上图中，左下角的两个值，没有任何引用，所以可以释放。\n\n如果一个值不再需要了，引用数却不为0，垃圾回收机制无法释放这块内存，从而导致内存泄漏。\n\n```\nconst arr = [1, 2, 3, 4];\nconsole.log('hello world');\n```\n上面代码中，数组[1, 2, 3, 4]是一个值，会占用内存。变量arr是仅有的对这个值的引用，因此引用次数为1。尽管后面的代码没有用到arr，它还是会持续占用内存。\n\n如果增加一行代码，解除arr对[1, 2, 3, 4]引用，这块内存就可以被垃圾回收机制释放了。\n\n```\nlet arr = [1, 2, 3, 4];\nconsole.log('hello world');\narr = null;\n```\n上面代码中，arr重置为null，就解除了对[1, 2, 3, 4]的引用，引用次数变成了0，内存就可以释放出来了。\n\n因此，并不是说有了垃圾回收机制，程序员就轻松了。你还是需要关注内存占用：那些很占空间的值，一旦不再用到，你必须检查是否还存在对它们的引用。如果是的话，就必须手动解除引用。\n\n### 内存泄漏的识别方法\n怎样可以观察到内存泄漏呢？\n\n经验法则是，如果连续五次垃圾回收之后，内存占用一次比一次大，就有内存泄漏。这就要求实时查看内存占用。\n\n#### 浏览器\nChrome 浏览器查看内存占用，按照以下步骤操作。\n\n![](http://www.ruanyifeng.com/blogimg/asset/2017/bg2017041704.png)\n\n* 打开开发者工具，选择 Timeline 面板\n* 在顶部的Capture字段里面勾选 Memory\n* 点击左上角的录制按钮。\n* 在页面上进行各种操作，模拟用户的使用情况。\n* 一段时间后，点击对话框的 stop 按钮，面板上就会显示这段时间的内存占用情况。\n\n如果内存占用基本平稳，接近水平，就说明不存在内存泄漏。\n\n![](http://www.ruanyifeng.com/blogimg/asset/2017/bg2017041705.png)\n\n反之，就是内存泄漏了。\n\n![](http://www.ruanyifeng.com/blogimg/asset/2017/bg2017041706.png)\n\n### WeakMap\n前面说过，及时清除引用非常重要。但是，你不可能记得那么多，有时候一疏忽就忘了，所以才有那么多内存泄漏。\n\n最好能有一种方法，在新建引用的时候就声明，哪些引用必须手动清除，哪些引用可以忽略不计，当其他引用消失以后，垃圾回收机制就可以释放内存。这样就能大大减轻程序员的负担，你只要清除主要引用就可以了。\n\nES6 考虑到了这一点，推出了两种新的数据结构：WeakSet 和 WeakMap。它们对于值的引用都是不计入垃圾回收机制的，所以名字里面才会有一个\"Weak\"，表示这是弱引用。\n\n```\nconst wm = new WeakMap();\n\nconst element = document.getElementById('example');\n\nwm.set(element, 'some information');\nwm.get(element) // \"some information\"\n```\n上面代码中，先新建一个 Weakmap 实例。然后，将一个 DOM 节点作为键名存入该实例，并将一些附加信息作为键值，一起存放在 WeakMap 里面。这时，WeakMap 里面对element的引用就是弱引用，不会被计入垃圾回收机制。\n\n也就是说，DOM 节点对象的引用计数是1，而不是2。这时，一旦消除对该节点的引用，它占用的内存就会被垃圾回收机制释放。Weakmap 保存的这个键值对，也会自动消失。\n\n基本上，如果你要往对象上添加数据，又不想干扰垃圾回收机制，就可以使用 WeakMap。\n\n\n## 结语\n生命不息，改bug不止...", "tag": "技术", "desc": "程序的运行需要内存。只要程序提出要求，操作系统或者运行时（runtime）就必须供给内存。", "tags": ["技术"], "created_at": 1506701894, "updated_at": 1506702016, "created_by": 77641313, "id": "5d14a14d6d0e617ee1d33455", "acl": "创建者可读, 创建者可写"}, {"title": "移动端兼容性及部分功能设置", "content": "## 概要\n\n本文档针对移动前端开发，包括 `Hybrid` 里面的web页面，非 `Native` 应用。\n\n## 适用\n\n所有经验适用于：`iOS6.0+`, `Android4.0+`\n\n## 兼容性\n\n### CSS伪类:active\n\n如果你想使用元素的伪类来实现 `按下激活` 状态，那么你需要知道以下问题：\n\n* iOS上的几乎任何浏览器，定义元素的伪类 `:active` 都是无效；\n* Android上，`Android Browser` 和 `Chrome` 都支持伪类 `:active` ，其它第三方浏览器有部分不支持；\n* 定义了 `:active` 并且当前浏览器环境支持，当手指在滚动或者无意间的划过时，`:active` 状态都会被激活；\n\n> 为了规避上述所有的问题，如果需要 `按下激活` 状态，推荐使用 `js` 新增一个 `className`\n\n### 清除输入框内阴影\n\niOS上的几乎任何浏览器输入框（input, textarea）默认有内部阴影，但无法使用 `box-shadow` 来清除，如果不需要阴影，可以这样关闭：\n\n```css\ninput,\ntextarea {\n\t/* 方法1: 去掉边框 */\n\tborder: 0;\n\n\t/* 方法2: 边框色透明 */\n\tborder-color: transparent;\n\n\t/* 方法3: 重置输入框默认外观 */\n\t-webkit-appearance: none;\n\tappearance: none;\n}\n```\n\n### 修正iOS输入框禁用文本色\n\n在 `iOS` 上，如果将输入框 `disabled`，此时输入框内的文字颜色将比 `color` 所定义的要浅，并且无法通过给输入框的伪类 `:disabled` 定义 `color` 来修正。\n\n想解决这个问题，可以作如下设置，定义输入框的文本填充色：\n\n```css\ninput:disabled {\n\t-webkit-text-fill-color: #000;\n}\n```\n\n需要注意的是，在 `Mac` 上的 `Safari` 也有同样的问题。\n\n### Samsung S4圆角Bug\n\n`Samsung S4` 手机在 `Android Browser4.4.2` 上（其他版本未测），如果你使用了 `border-radius`，并且使用了 `-webkit-transform` 属性，当使用了 `translatez` 或者 `translate3d` 值，圆角会出现问题：\n\n```css\n.test {\n\tborder: 2px solid red;\n\twidth: 50px;\n\theight: 50px;\n\tborder-radius: 50%;\n\tbackground-color: gray;\n\tbox-shadow: 0 2px 5px rgba(0, 0, 0, .3);\n\t-webkit-transform: translate(0, 0) translatez(0);\n\ttransform: translate(0, 0) translatez(0);\n}\n```\n```html\n<div class=\"test\"></div>\n```\n\n如上代码，`-webkit-transform: translate(0, 0) translatez(0)` 将会导致圆角无法包裹住 `background-color`。\n\n当然，`-webkit-transform: translate3d(0, 0, 0)` 也是一样的，所以如果你的某个场景是这样的，那么可以直接使用 `-webkit-transform: translate(0, 0)` 来避免这个问题。\n\n### 边框圆角致背景溢出\n\n在红米和OPPO等手机某些版本的 `Android Webview` 中，如果一个元素定义了 `border` + `border-radius`，这时如果该元素有背景，那么背景将会溢出圆角之外。\n\n之所以会出现这个问题：其主要原因是因为CSS对背景裁剪（background-clip）有不同的处理方式，通常它可以是 `border-box | padding-box | content-box` 这3种方式。\n\n浏览器的默认裁减方式是 `border-box`，即溢出 `border` 之外的背景都将被裁减。\n\n对于上述无法裁减边框之外背景的手机，将值定义为 `padding-box | content-box` 都能fix这问题，不过更推荐使用 `padding-box`。因为使用 `content-box`，如果定义了 `padding` 不为 `0`，背景将无法铺满元素。\n\n\n### 一个失败的圆（圆角）\n\n在移动平台上开发时，用CSS画一个圆很简单，只需要一句代码：\n\n```css\n.circle {\n\tborder-radius: 50%;\n}\n```\n不过，在 `Android Browser2.*` 上，这个定义将会失效，而显示为默认的矩形。\n\n因为 `Android Browser2.*` 不支持以 `百分比` 作为 `border-radius` 的值，所以如果你需要兼容 `Android Browser2.*`，那么你可以这样：\n\n```css\n.circle {\n\twidth: 10rem;\n\theight: 10rem;\n\tborder-radius: 5rem;\n}\n```\n如果你觉得这样定义不够灵活，想懒一点，那么其实可以给 `border-radius` 预设一个比较大的值，比如 `100rem`，用以避免当元素的尺寸变了，圆角半径也得跟着变，除非元素的尺寸超出了你预设的阀值。\n\n\n### 不要使用伪元素动画\n\n有的时候你可能会为了减少页面上的DOM数，而使用伪元素。但如果你想给伪元素增加 `animation` 或者 `transition` 动画，这时候会碰上支持性问题。\n\n如果你的项目需要支持以下系统版本，那么建议直接使用真实元素：\n\n* `iOS Safari6.1及以下`\n* `Android Browser4.1.*及以下`，包括一些深度定制的系统，比如：\n    * 魅族 - Flyme OS 4.1.1.1C及以下（比这高的版本尚未测试过）- **咱国产能别这么坑么（安卓版本为4.4.4的魅族MX4 pro）**\n\n### :checked与兄弟选择符一起使用的bug\n\n在 `Android Browser4.2.*及以下`（可能版本稍有出入）（包括坑爹的Flyme），如果你有这样一段代码：\n\n```css\ninput:checked ~ .test {\n  background-color: #f00;\n}\n```\n\n那么将无任何效果，如果你想使得上述代码生效，有2种方式：\n\n第一种，使用 `input` 和 `+` 进行激活：\n\n```css\nhtml + input {}\ninput:checked ~ .test {\n  background-color: #f00;\n}\n```\n\n只要存在 `input`和 `+` 选择符配合使用的选择器（空规则集也行）即可使得上述代码激活生效。\n\n第二种，直接换成 `+`：\n\n```css\ninput:checked + .test {\n  background-color: #f00;\n}\n```\n\n### 为什么flex布局不生效\n\n* 使用[块级元素](http://blog.doyoe.com/2015/03/09/css/%E8%A7%86%E8%A7%89%E6%A0%BC%E5%BC%8F%E5%8C%96%E6%A8%A1%E5%9E%8B%E4%B8%AD%E7%9A%84%E5%90%84%E7%A7%8D%E6%A1%86/#block-level-element)作为 `flex items（flex子项）`；\n\n> `Android Browser4.3及以下`，`iOS Safari6.1及以下` 的 `flex子项` 需要使用块级元素，在这些版本之上还可以使用行内块元素\n\n> 在这些版本中，如果你发现flex子项之间出现了间隙，或者在未定义换行的情况下子项自身抑或子项之间换行了，或者出现了其它不正常的情况，那么仔细看一下flex子项可能是使用了行内级元素；\n\n* 当横向布局时，给 `flex子项` 子项定义 `width` 为非 `auto` 的值\n\n> `Android Browser4.3及以下`，`iOS Safari6.1及以下` 的 `flex子项` 如果没有显式的定义 `width` 为非 `auto` 的值，那么子项分配父元素剩余空间时将会不符合标准预期；\n\n* 当纵向布局时，给 `flex子项` 子项定义 `height` 为非 `auto` 的值\n\n> `Android Browser4.3及以下`，`iOS Safari6.1及以下` 的 `flex子项` 如果没有显式的定义 `height` 为非 `auto` 的值，那么子项分配父元素剩余空间时将会不符合标准预期；\n\n### 为什么小于12px字号不生效\n\n如果你是从`pc`开发转到移动平台的，或者应该记得在`pc`端，`Chrome`及后来加入Webkit阵营的`Opera`都不支持页面字号小于`12px`，当然你可以通过更改浏览器设置来改变这一情况，然后这并没有什么卵用，不是么？\n\n不幸的是，在移动端这个限制也依然存在，在`Android Chrome`上（包括部分版本上的`Android Browser`），仍然不支持小于12px的字号（测试至Android5.0.2, Chrome46），除此之外，其他浏览器包括iOS上众浏览器都能够很好的支持超小字体。\n\n所以，如果希望你的程序足够安全，尽量不要定义小于12px的字号，或者换一种方式来实现。\n\n> 题外话：假设你的项目使用了`rem`，那么不要使用`10`作为换算因子，原因也如上\n\n### chrome中body使用rem失效\n\n我知道很多人已经开始使用 `rem` 作为项目中的单位了。但是遗憾的是，在 `Chrome` 和 `Opera` 上，如果我们给 `body` 元素应用了 `rem`，那么这个取值将会计算错误。\n\n假设我们有如下代码：\n\n```css\nhtml {\n  font-size: 62.5%;\n}\nbody {\n  font-size: 1.4rem;\n}\n```\n\n因为大部分浏览器的默认字号都是 `16px`，所以 `html` 的字号计算出来应该是 `16px * 62.5% = 10px`。此时，我们预期 `body` 的 `font-size` 为 `14px`。然而实际情况与我们想象的不太一样，最终 `body` 的计算值并不是 `14px`，它忽略了 `html` 的定义，而是直接使用了浏览器的默认字号作为参照。于是最终计算值为：`16px * 1.4rem = 22.4px`。测至 `chrome 45.0` 和 `Opera 33.0` 仍然存在这个问题，不过 `chrome 49.0` 和 `Opera 37.0` 看起来已经被修复了。\n\n为了有效的绕过这个问题，并且实现相同的效果，我们可以将代码修改如下：\n\n```css\nhtml {\n  font-size: 62.5%;\n}\nbody {\n  font-size: 1.4em;\n}\n```\n\n由于 `body` 是 `html` 的直接子元素，所以此时对 `body` 使用 `em` 与 `rem` 的效果是相同的。\n\n### 不要对html设置百分比字号\n\n很严肃的和大家说，如果你在使用 `rem` 这项技术，那么尽可能不要对html设置百分比大小的字号。比如这样的：\n\n```css\nhtml {\n  font-size: 62.5%;\n}\n```\n\n由于大部分浏览器的默认字号是 `16px`，所以能计算出 `html` 的字号实际为 `10px`。我们在 [为什么小于12px字号不生效](#user-content-12px) 中说过，部分浏览器会将小于 `12px` 的字变成 `12px` 来显示。那么此时，在这些浏览器下，如果我做了这样的定义：\n\n```css\n.demo {\n\twidth: 10rem;\n}\n```\n\n你预期得到 `10px * 10rem = 100px`，但实际上得到的确是 `12px * 10rem = 120px`。这是非常大的错误，我们应当尽量避免。\n\n与此同时，虽然大部分浏览器的默认字号是 `16px`，但仍然有使用其它默认值的浏览器，比如我依稀记得 `firefox` 使用了 `15px`。**而且最重要的是，用户是可以改变浏览器默认字号的**，所以你认为的可能并不是你认为的。\n\n所以不要对html设置百分比字号，尤其是不要对它使用计算值比 `12px` 小的字号。我推荐大家这样做：\n\n```css\nhtml {\n  font-size: 100px;\n}\n```\n\n以 `100px` 作为因子，计算也非常方便。如果你想要设置一个元素的宽度是 `20px`，那么只需要：\n\n```css\n.demo {\n\twidth: .2rem;\n}\n```\n\n## 功能设置\n\n### 禁止保存或拷贝图像\n\n通常当你在手机或者pad上长按图像 `img` ，会弹出选项 `存储图像` 或者 `拷贝图像`，如果你不想让用户这么操作，那么你可以通过以下方法来禁止：\n\n```css\nimg {\n\t-webkit-touch-callout: none;\n}\n```\n\n> 需要注意的是，该方法只在 `iOS` 上有效。\n\n### 取消touch高亮\n\n在移动设备上，所有设置了伪类 `:active` 的元素，默认都会在激活状态时，显示高亮框，如果不想要这个高亮，那么你可以通过以下方法来禁止：\n\n```css\n.xxx {\n\t-webkit-tap-highlight-color: rgba(0, 0, 0, 0);\n}\n```\n\n### 禁止选中内容\n\n如果你不想用户可以选中页面中的内容，那么你可以禁掉：\n\n```css\nhtml {\n\t-webkit-user-select: none;\n}\n```\n\n### 快速回弹滚动\n\n1. 早期的时候，移动端的浏览器都不支持非body元素的滚动条，所以一般都借助 iScroll;\n2. Android 3.0/iOS解决了非body元素的滚动问题，但滚动条不可见，同时iOS上只能通过2个手指进行滚动；\n3. Android 4.0解决了滚动条不可见及增加了快速回弹滚动效果，不过随后这个特性又被移除；\n4. iOS从5.0开始解决了滚动条不可见及增加了快速回弹滚动效果\n\n在iOS上如果你想让一个元素拥有像 Native 的滚动效果，你可以这样做：\n\n```css\n.xxx {\n\toverflow: auto; /* auto | scroll */\n\t-webkit-overflow-scrolling: touch; /* 该规则可能引起iOS UIWebView崩溃 */\n}\n```\n\n### 设置添加到主屏幕的Web App标题\n\n`iOS Safari` 允许用户将一个网页添加到主屏幕然后像 `App` 一样来操作它。我们知道每个 `App` 下方都会有一个名字，`iOS Safari` 提供了一个私有的 `meta` 来定义这个名字，代码如下：\n\n```html\n<meta name=\"apple-mobile-web-app-title\" content=\"Web App名称\" />\n```\n\n`Android Chrome31.0`，`Android Browser5.0` 也开始支持添加到主屏幕了，但并没有提供相应的定义标题的方式，所以如果你想统一 `iOS` 和 `Android` 平台定义 Web app 名称的方式，可以使用 `title` 标签来定义，代码如下：\n\n```html\n<title>Web App名称</title>\n```\n\n但如果你想要网页标题和App名字不一样的话，那就只有iOS才行。\n\n### 设置添加到主屏幕的Web App图标\n\n当我们将一个网页添加到主屏幕时，除了会需要设置标题之外，肯定还需要能够自定义这个App的图标，代码如下：\n\n```html\n<link rel=\"apple-touch-icon\" href=\"app.png\" />\n```\n\n不过该方案，在拟物设计的 `iOS6及以前` 会自动为图标添加一层高光效果，`iOS7` 已使用了扁平化设计，所以如果使用该方案，在不同版本下得到的效果会不一致。\n\n当然，你也可以使用原图作为App的图标，用以保持各平台表现一致，代码如下：\n\n```html\n<link rel=\"apple-touch-icon-precomposed\" href=\"app.png\" />\n```\n\n如果你想给不同的设备定不同的图标，可以通过 `sizes` 属性来定义，形如：\n\n```html\n<link rel=\"apple-touch-icon\" sizes=\"76x76\" href=\"ipad.png@1x\" />\n<link rel=\"apple-touch-icon\" sizes=\"120x120\" href=\"iphone-retina@2x.png\" />\n<link rel=\"apple-touch-icon\" sizes=\"152x152\" href=\"ipad-retina@2x.png\" />\n<link rel=\"apple-touch-icon\" sizes=\"180x180\" href=\"iphone-retina@3x.png\" />\n```\n\n规则如下：\n\n* 如果没有跟相应设备推荐尺寸一致的图标，会优先选择比推荐尺寸大并且最接近推荐尺寸的图标。\n* 如果没有比推荐尺寸大的图标，会优先选择最接近推荐尺寸的图标。\n* 如果有多个图标符合推荐尺寸，会优先选择包含关键字precomposed的图标。\n\n实际情况下，大部分智能手机都接近或者已经达到视网膜屏质量，所以如果想省事的话，可以分别为 `iPhone` 和 `iPad` 定义一种高质量的 `icon` 即可。\n\n该方案在 `iOS` 和 `Android5.0+` 上都通用。\n\n### 添加到主屏幕时隐藏地址栏和状态栏（即全屏）\n\n当我们将一个网页添加到主屏幕时，会更希望它能有像 `App` 一样的表现，没有地址栏和状态栏全屏显示，代码如下：\n\n```html\n<meta name=\"apple-mobile-web-app-capable\" content=\"yes\" />\n```\n\n该方案在 `iOS` 和 `Android5.0+` 上都通用。\n\n### 添加到主屏幕时设置系统顶栏颜色\n\n当我们将一个网页添加到主屏幕时，还可以对 `系统显示手机信号、时间、电池的顶部状态栏` 颜色进行设置，前提是开启了：\n\n```html\n<meta name=\"apple-mobile-web-app-capable\" content=\"yes\" />\n```\n\n有了这个前提，你可以通过下面的方式来进行定义：\n\n```html\n<meta name=\"apple-mobile-web-app-status-bar-style\" content=\"black\" />\n```\n\ncontent只有3个固定值可选：default | black | black-translucent\n\n* 如果设置为 `default`，状态栏将为正常的，即白色，网页从状态栏以下开始显示；\n* 如果设置为 `black`，状态栏将为黑色，网页从状态栏以下开始显示；\n* 如果设置为 `black-translucent`，状态栏将为灰色半透明，网页将充满整个屏幕，状态栏会盖在网页之上；\n\n该设置只在 `iOS` 上有效。\n\n### 电话号码识别\n\n在 `iOS Safari` （其他浏览器和Android均不会）上会对那些看起来像是电话号码的数字处理为电话链接，比如：\n\n* 7位数字，形如：1234567\n* 带括号及加号的数字，形如：(+86)123456789\n* 双连接线的数字，形如：00-00-00111\n* 11位数字，形如：13800138000\n\n可能还有其他类型的数字也会被识别，但在具体的业务场景中，有些时候这是不必须的，所以你可以关闭电话自动识别，然后在需要拨号的地方，开启电话呼出和短信功能。\n\n1. 关闭电话号码识别：\n\n```html\n<meta name=\"format-detection\" content=\"telephone=no\" />\n```\n\n2. 开启拨打电话功能：\n\n```html\n<a href=\"tel:123456\">123456</a>\n```\n\n3. 开启发送短信功能：\n\n```html\n<a href=\"sms:123456\">123456</a>\n```\n\n### 邮箱地址识别\n\n在 `Android` （iOS不会）上，浏览器会自动识别看起来像邮箱地址的字符串，不论有你没有加上邮箱链接，当你在这个字符串上长按，会弹出发邮件的提示。\n\n1. 关闭邮箱地址识别：\n\n```html\n<meta name=\"format-detection\" content=\"email=no\" />\n```\n\n2. 开启邮件发送：\n\n```html\n<a href=\"mailto:dooyoe@gmail.com\">dooyoe@gmail.com</a>\n```\n\n> 如果想同时关闭电话和邮箱识别，可以把它们写到一条 meta 内，代码如下：\n\n```html\n<meta name=\"format-detection\" content=\"telephone=no,email=no\" />\n```\n\n### 关闭iOS键盘首字母自动大写\n\n在iOS中，默认情况下键盘是开启首字母大写的功能的，如果业务不想出现首字母大写，可以这样：\n\n```html\n<input type=\"text\" autocapitalize=\"off\" />\n```\n\n### 关闭iOS输入自动修正\n\n在iOS中，默认输入法会开启自动修正输入内容的功能，如果不需要的话，可以这样：\n\n```html\n<input type=\"text\" autocorrect=\"off\" />\n```\n\n### 禁止文本缩放\n\n当移动设备横竖屏切换时，文本的大小会重新计算，进行相应的缩放，当我们不需要这种情况时，可以选择禁止：\n\n```css\nhtml {\n\t-webkit-text-size-adjust: 100%;\n}\n```\n\n> 需要注意的是，PC端的该属性已经被移除，该属性在移动端要生效，必须设置 `meta viewport'", "tag": "技术", "desc": "本文档针对移动前端开发，包括 `Hybrid` 里面的web页面，非 `Native` 应用。", "tags": ["技术", "移动端"], "created_at": 1505736060, "updated_at": 1561633329, "created_by": 77641313, "id": "5d14a21a6d0e610d9a4696fe", "acl": "创建者可读, 创建者可写"}, {"title": "IntelliJ IDEA中自动压缩js,css文件", "content": "最近有个需求，要求使用IntelliJ IDEA编辑器时能够自动压缩js或者是css文件，于是乎就开始了百度、必应、谷歌。。。试了数不清的方法，结果发现还是没有用，最终在几个教程的综合之下加上一些运气，该功能得以实现。写个安装教程，争取别人看后能够一目了然。\n\n使用此功能的前提是：\n1. 确保本机以及安装了NodeJS以及npm(具体安装方法不再阐述)\n2. intellij idea下以及安装了File Watchers插件([webstorm和intellij idea下如何自动编译sass和scss文件](https://segmentfault.com/a/1190000008996504))\n\n#### 安装JavaScript压缩工具(以YUI Compressor为例)\n\n```\nnpm i yuicompressor -g\n```\n![安装](https://gwemz.gitee.io/images/2017-8-9-1.png)\n\n点击：`File - Settings - Tools - File Watchers`进入相应目录\n![location](https://gwemz.gitee.io/images/2017-8-9-2.png)\n\n添加插件目录：\n![](https://gwemz.gitee.io/images/2017-8-9-3.png)\n值得注意的是在选择工具的安装目录的时候选择yuicompressor.cmd而非yuicompressor\n![](https://gwemz.gitee.io/images/2017-8-9-4.png)\n新建js文件，将会自动生成  相应文件名.min.js压缩文件\n![](https://gwemz.gitee.io/images/2017-8-9-5.png)\n#### CSS压缩工具同JavaScript工具配置方法类似，可自行去研究使用\n\n#### 结语\n\n在项目开发过程中，遇到各种各样的问题再正常不过，所幸我们不是一个人在战斗，在互联网这么发达的时代，有千千万万素昧平生的人可以是我们的老师，只要潜心研究，相信一定可以找到解决问题的方式。虽说遇到问题是好事，因为你可以从解决问题的过程中提升自我，当然我也保佑你不要所有的问题都让你遇到，这就过于恶心。还是适中一点较好。", "tag": "技术", "desc": "IntelliJ IDEA编辑器如何自动压缩js或者是css文件", "tags": ["技术"], "created_at": 1502292223, "updated_at": 1502292523, "created_by": 77641313, "id": "5d14a4206d0e6137d6d32a9d", "acl": "创建者可读, 创建者可写"}, {"title": "px-em-rem的区别", "content": "在移动端布局的过程中使用rem进行布局，一直以来的思路是浏览器监测屏幕宽度的大小，通过计算改变html中不同的font-size的值，来改变rem的相对值，但其实发现对其中的原理并不是很清楚，索性写篇文章做个整理，尽量将三者的关系区分开\n\n## 有何区别？\n\n* px在缩放页面时无法调整哪些使用它作为单位的字体、按钮等的大小\n* em的值不是固定的，会继承父级元素的字体大小，代表倍数\n* rem的值并不是固定的，始终是基于根元素<html>的，也代表倍数\n\n#### em\nem的使用是相对于其父级元素的大小的，即倍数。浏览器的默认字体高都是16px，未经调整的浏览器显示1em=16px.但是有一个问题，如果设置1.2em则变成19.2px，问题是px表示大小时会忽略掉小数位的(你想象不出来半个像素吧).而且1em=16px的关系并不好转，因此，常常人为的使1em = 10px.这里要借助字体的%来作为桥梁。\n\n因为默认时字体16px = 100%,则有10px = 62.5%。所以首先在body中全局声明font-size=62.5%=10px,也就是定义了网页body默认字体大小为10px。由于em有继承父级元素大小的特性，如果某元素的父级没有设定字体大小，那么它就继承了body默认字体大小1em = 10px;\n\n但是由于em是相对于其父级字体的倍数的，当出现有多重嵌套内容时，使用em分别给他们设置字体的大小往往要重新计算。比如说你在父级元素中声明了字体大小为1.2em,那么在声明子元素的字体大小时设置1em才能和父级元素内容大小一致，而不是1.2em(避免1.2*1.2=1.44em),因为此em非彼em。\n\nexample:\n```\n<span>Outer <span>inner</span> Outer</span>\n\nbody{font-size:62.5%;}\nspan{font-size:1.6em;}\n```\n结果，外层<span>为body字体10px的1.6倍=16px,内层<span>字体为外层内容字体16px的1.6倍25px(或26px，不同浏览器取舍小数不同)。\n\n明显的，内部<span>内的文字受到了外父级<span>元素的影响。基于这点，在实际中给我们的计算带来了很大的不方便。\n\n#### rem\nrem的出现再也不用担心还要根据父级元素的font-size计算em的值了，因为它始终是基于根元素(<html>)的。\n\n比如默认的html font-size:16px,那么想要设置12px文字就是：12/16 = 0.75rem;\n\n```\n\nhtml{font-size:62.5%;}   (16px -> 100% 1rem -> 10px -> 62.5%)\n\nspan{font-size:16px;font-size:1.6rem;}\n\n```\n\n结果：内外的<span>的字体大小均为16px;\n\n想要注意的是，为了兼容不支持rem的浏览器，我们需要在各个使用了rem地方前面写上对应px的值，这样不支持的浏览器可以优雅降级。\n\n最后，选择什么样的字体单位由你的项目来决定，如果你的用户群都使用最新的浏览器，那推荐使用rem，如果要考虑兼容性，那就使用px，或者两者同时使用。\n", "tag": "技术", "desc": "在移动端布局的过程中使用rem进行布局", "tags": ["技术", "CSS"], "created_at": 1502109763, "updated_at": 1502110129, "created_by": 77641313, "id": "5d14a4c96d0e6135414689df", "acl": "创建者可读, 创建者可写"}, {"title": " Flex布局语法及示例", "content": "## 背景\n网页布局(layout)是css的一个重要应用\n布局的传统解决方案，基于盒装模型，依赖display+position+float属性。对于特殊布局，如垂直居中就不容易实现。\n## 发展\n![flex-1](https://gwemz.gitee.io/images/7-29-1.png)\n2009年，W3C提出了一种新的方案---Flex布局，可以简便、完整、响应式地实现各种页面布局。目前，它已经得到了所有浏览器的支持，这意味着，我们可以安全的使用这项功能。\n![flex-2](https://gwemz.gitee.io/images/7-29-2.jpg)\nflex布局将成为未来布局的首选方案，flex布局示例请参考: [Flex布局示例](https://gwemz.coding.me/flex/)\n\n## 语法\n### Flex布局是什么？\nFlex是 Flexible Box的缩写，意为“弹性布局”，用来为盒装模型提供最大的灵活性。\n任何一个容器都可以指定为Flex布局\n```\n.box{\n  display:flex;\n}\n```\n行内元素也可以使用flex布局\n```\n.box{\n  display:inline-block;\n}\n```\nWebkit内核的浏览器，必须加上-webkit前缀\n```\n.box{\n  display:-webkit-flex; /* Safari */\n  display:flex;\n}\n```\n注意：设为Flex布局之后，子元素的float、clear和vertical-align属性将消失\n<div class=\"page-break\"></div>\n\n### 基本概念\n采用Flex布局的元素，称为Flex容器(flex container)，简称“容器”。它的所有子元素自动成为容器成员，称为Flex项目(flex item),简称\"项目\"。\n![flex-3](https://gwemz.gitee.io/images/7-29-3.png)\n容器默认存在两根轴：水平的主轴(main axis)和垂直的交叉轴(cross axis)。主轴的开始位置（与边框的交叉点）叫做`main start`，结束位置叫做 `main end`；交叉轴的开始位置叫做 `cross start`，交叉轴的结束位置叫做 `cross end`。项目默认沿主轴排列。单个项目占据的主轴空间叫`main size`，占据的交叉轴空间叫做`cross size`。\n### 容器的属性\n6个属性设置在容器上\n* flex-direction（决定主轴的方向 即项目的排列方向）\n* flex-wrap（项目如果在一条轴线上排不下将如何换行）\n* flex-flow（flex-direction和flex-wrap的简写形式）\n* justify-content（项目在主轴上的对齐方式）\n* align-items（项目在交叉轴上的对齐方式）\n* align-content（定义了多根轴线的对齐方式）\n\n#### flex-direction属性\n`flex-direction`属性决定主轴的方向(即项目的排列方向)\n```\n.box{\n  flex-direction:row | row-reverse | column | column-reverse;\n}\n```\n它有四个值：\n* row(默认值)：主轴为水平方向，起点在左端\n* row-reverse: 主轴为水平方向，起点在右端\n* column: 主轴为垂直方向，起点在上端\n* column-reverse: 主轴为垂直方向，起点在下端\n\n#### flex-wrap属性\n默认情况下，项目都排列在一条轴线上，`flex-wrap`属性定义，如果一条轴线排不下，如何换行。\n```\n.box{\n  flex-wrap: nowrap | wrap | wrap-reverse;\n}\n```\n它取三个值：\n* nowrap(默认值)：不换行\n* wrap：换行，第一行在上方\n* wrap-reverse：换行，第一行在下方\n\n#### flex-flow属性\n`flex-flow`属性是`flex-direction`和`flex-wrap`属性的简写形式，默认值为`row nowrap`\n```\n.box{\n  flew-flow: <flex-direction> || <flex-wrap>;\n}\n```\n\n#### justify-content属性\n`justify-content`属性定义了项目在主轴上的对齐方式。\n```\n.box{\n  justify-content: flex-start | flex-end | center | space-between | space-around;\n}\n```\n它有5个值，具体对齐方式与轴的方向有关。（假设主轴为从左向右）\n* flex-start(默认值)：左对齐\n* flex-end：右对齐\n* center：居中\n* space-between：两端对齐，项目之间的间隔都相等\n* space-around：每个项目两侧的间隔相等。所以，项目之间的间隔比项目与边框的间隔大一倍。\n\n#### align-items属性\n`align-items`属性定义了项目在交叉轴上如何对齐\n```\n.box{\n  align-items: flex-start | flex-end | center | baseline | stretch;\n}\n```\n它可能取5个值。具体对齐方式与交叉轴的方向有关，假设交叉轴从上到下\n* flex-start：交叉轴的起点对齐\n* flex-end：交叉轴的终点对齐\n* center：交叉轴的中点对齐\n* baseline：项目的第一行文字的基线对齐\n* stretch(默认值)：如果项目为设高度或设为auto，将占满整个容器的高度。\n\n#### align-content属性\n`align-content`属性定义了多根轴线的对齐方式。如果项目只有一根属性，则该属性不起作用。\n```\n.box{\n  align-content: flex-start | flex-end | center | space-between | space-around | stretch;\n}\n```\n该属性可取6个值：\n* flex-start：与交叉轴的起点对齐\n* flex-end：与交叉轴的终点对齐\n* center：与交叉轴的中点对齐\n* space-between：与交叉轴两端对齐，轴线之间的间隔平均分布\n* space-around：每根轴线两侧的间隔都相等。所以，轴线之间的间隔比轴线与边框的间隔大一倍\n* stretch(默认值)：轴线占满整个交叉轴\n\n### order属性\n`order`属性定义项目的排列顺序。数值越小，排列越靠前，默认为0\n```\n.item{\n  order:<integer>;\n}\n```\n### flex-grow属性\n`flex-grow`属性定义项目的放大比例，默认为0，即如果存在剩余空间，也不放大。\n```\n.item{\n  flex-grow:<number>; /*default 0*/\n}\n```\n如果所有的`flex-grow`属性值都为1，则它们将等分剩余空间（如果有的话）。如果一个项目的flex-grow属性为2，其他项目都为1，则前者占据的剩余空间将比其他项多一倍。\n\n### flex-shrink属性\n`flex-shrink`属性定义了项目的缩小比例，默认为1，即如果空间不足，该项目将缩小\n```\n.item{\n  flex-shrink:<number>; /*default 1*/\n}\n```\n如果所有项目的flex-shrink属性都为1，当空间不足时，都将等比例缩小。如果一个项目的flex-shrink属性值为0，其他项目都为1，则空间不足时，前者不缩小。\n负值对该属性无效。\n\n### flex-basis属性\n`flex-basis`属性定义了在分配多余空间之前，项目占据的主轴空间(main size)。浏览器根据这个属性，计算主轴是否有多余空间。它的默认值为 `auto`，即项目的本来大小。\n```\n.item{\n  flex-basis:<length> | auto; /*default auto*/\n}\n```\n它可以设为跟width或height一样的值（比如350px）,则项目将占据固定空间。\n\n### flex属性\n`flex`属性是`flex-grow`,`flex-shrink`和 `flex-basis`的简写，默认值为0 1 auto。后两个属性可选。\n```\n.item{\n  flex: none | [ <'flex-grow'> <'flex-shrink'>? || <'flex-basis'> ]\n}\n```\n该属性有两个快捷值：auto(1 1 auto)和none(0 0 auto)。\n建议优先使用这个属性，而不是单独写三个分离的属性，因为浏览器会推算相关值。\n\n### align-self属性\n`align-self`允许单个项目有与其他项目不一样的对齐方式，可覆盖`align-items`属性。默认值为auto，表示继承父元素的`align-items`属性，如果没有父元素，则等同于stretch。\n```\n.item{\n  align-self:auto | flex-start | flex-end | center | baseline | stretch;\n}\n```\n该属性可取6个值，除了auto,其他都与align-items属性值完全一致。\n\n## The end!\npractice more\n", "tag": "技术", "desc": "布局的传统解决方案，基于盒装模型，依赖display+position+float属性。", "tags": ["技术", "CSS"], "created_at": 1501296045, "updated_at": 1501296050, "created_by": 77641313, "id": "5d14a58b6d0e6137d6d33040", "acl": "创建者可读, 创建者可写"}, {"title": "Js中Date和new Date的区别", "content": "#### 1.Date()直接返回当前时间字符串，不管参数是number还是任何string\n```\nDate();\nDate('sssss');\nDate(1000);\n//Fri Aug 21 2015 15:46:21 GMT+0800 (中国标准时间)\n```\n#### 2.而new Date()则是会根据参数来返回对应的值，无参数的时候，返回当前时间的字符串形式；有参数的时候返回参数所对应时间的字符串。new Date()对参数不管是格式还是内容都要求,且只返回字符串\n```\nnew Date();\n//Fri Aug 21 2015 15:51:55 GMT+0800 (中国标准时间)\n\nnew Date(1293879600000);\nnew Date('2011-01-01T11:00:00')\nnew Date('2011/01/01 11:00:00')\nnew Date(2011,0,1,11,0,0)\nnew Date('jan 01 2011,11 11:00:00')\nnew Date('Sat Jan 01 2011 11:00:00')\n//Sat Jan 01 2011 11:00:00 GMT+0800 (中国标准时间)\n\nnew Date('sss');\nnew Date('2011/01/01T11:00:00');\nnew Date('2011-01-01-11:00:00')\nnew Date('1293879600000');\n//Invalid Date\n\nnew Date('2011-01-01T11:00:00')-new Date('1992/02/11 12:00:12')\n//596069988000\n```\nnew Date()对参数有严格的要求，格式不准确的时候会返回Invalid Date", "tag": "技术", "desc": "Date()直接返回当前时间字符串，不管参数是number还是任何string", "tags": ["技术", "JS"], "created_at": 1500258508, "updated_at": 1500258748, "created_by": 77641313, "id": "5d14a62a6d0e6132a4468b90", "acl": "创建者可读, 创建者可写"}, {"title": "front-end-developers-interview", "content": "#### 1.CSS盒模型包含哪些元素:\ncontent(内容) 、padding(填充) 、border(边框) 、margin(边界)\n#### 2.写出你知道的清除浮动的方法\n方法一：使用带有clear属性的空元素\n```\n在浮动元素后添加一个空元素如<div class=\"clear\"></div>\n.clear{\n  clear:both;\n}\n亦可使用<hr class=\"clear\"/>或<br class=\"clear\"/>来清理\n```\n方法二：使用CSS的:after伪元素\n```\n<div class=\"container clearfix\"></div>\n.clearfix:after{\n  content:\"\";\n  display:block;\n  height:0;\n  clear:both;\n}\n为了考虑到IE6/IE7浏览器，可以给clearfix添加zoom:1;\n.clearfix{\n  zoom:1;\n}\n```\n方法三：使用css的overflow:hidden;属性进行处理\n给浮动元素的容器添加overflow:hidden;或overflow:auto;可以怪异清理浮动\n```\n<div class=\"container\">\n  <div class=\"floatleft\"></div>\n  <div class=\"floatright\"></div>\n</div>\n\n.container{\n  overflow:hidden;\n}\n.container{\n  overflow:auto;\n}\n```\n方法四：给浮动元素的容器添加浮动\n给浮动元素的容器添加浮动属性即可清理内部浮动,使用方便但是会对文档造成影响\n```\n<ul class=\"menu\">\n  <li class=\"floatleft\"></li>\n  <li class=\"floatright\"></li>\n</ul>\n.menu{\n  float:left;\n}\n```\n方法五：使用邻接元素清理\n给浮动元素后边的元素添加clear属性\n```\n<div class=\"container\">\n  <div class=\"floatleft\">\n  <div class=\"floatright\">\n  <div class=\"content\"></div>\n</div>\n.content{\n  clear:both;\n}\n```\n确保的是content元素和floatleft、floatright元素在同一个父元素内\n方法六：使用display:table\n使用display:table模拟表格布局也可解决浮动问题，并可以自动对齐高度。但是table存在一系列问题，建议不使用。\n#### 3.CSS选择器的优先级\n!important > 行内样式 > 后代、交叉 > ID > class > 标签选择器 > * >浏览器预定义样式 > 继承样式\n#### 4.让子块元素相对于父元素居中\n```\n<div class=\"parent\">\n  <div class=\"child\"></div>\n</div>\n方法一：\n.parent{\n  text-align:center;\n}\n.child{\n  display:inline-block;\n}\n方法二：\n.child{\n  margin:0 auto;\n}\n```\n#### 5.说下opacity:0,visibility:hidden,display:none的区别\nopacity:0;该元素被隐藏起来了，但不会改变页面布局，并且，如果该元素已经绑定了一些事件，如click事件，那么点击该区域，也能触发点击事件的.\nvisibility:hidden;该元素被隐藏起来了，但是不会改变页面布局，但是不会触发该元素已经绑定的事件\ndisplay:none;把元素隐藏起来，并且会改变页面布局，可以理解成在页面中把该元素删掉一样\n#### 6.微信HTML5页面制作\n1.H5页面正规流程下需要用什么软件制作（不要网上那种几张图片摆摆自动生成的）\n首先需要澄清一下，H5页面，全称HTML5页面，指的其实是充分利用HTML5技术的网页。而网页，归根其实就是资源＋CSS＋HTML5+JAVASCRIPT代码，涉及到服务端请求的，还需要后端的支持，因此制作丰富精美的HTML5页面，如果细化一下你所说的正规流程：\n－文案出策划案与线框图。（笔、Balsamiq Mockup）\n－设计师出高保真原型（PSD、Sketch、Axure）。\n－程序（前端后端撰写JavaScript／CSS／HTML代码，后端代码PHP、Node.JS等）\n其实你提到的网上生成的最终只是把这些步骤通过页面自动帮你实现了，生成的代码页是这些。\n2.需要用到哪些技术（比如哪些程序语言）\n前端表现效果：HTML、CSS、JAVASCRIPT\n后端实现：PHP、Node.JS等。\n3.微信里的一些特殊的动态效果，比如摇一摇、倾斜手机、举起手机是怎样实现的\n有些是微信特有的，有些是浏览器本身就支持的。\n这些其实取决于微信特定的功能开放清单，有些可以做有些不可以做，只要程序根据微信的开放API文档即可实现，文档在这里。\n[微信公众平台开发概述](https://mp.weixin.qq.com/wiki?t=resource/res_main&id=mp1445241432)\n[微信提供的JS－SDK工具](https://mp.weixin.qq.com/wiki?t=resource/res_main&id=mp1445241432)\n4.H5页面怎样发布到微信上\nH5页面其实就是个链接，你可以通过直接将该链接发送给好友、朋友圈、嵌入公众号、嵌入公众号图文\n也可以通过生成二维码来让用户通过识别二维码来查看链接。\n[草料二维码生成器](http://cli.im/)\n5.有什么相关参考资料\n其实对于常见的HTML5工具，取决于你所要制作的形式，对于常见互动展示类，易企秀、MAKA其实足矣，功能非常强大，模版也很丰富。\n如果你需要的更多互动，甚至游戏类，可以推荐采用24好玩平台。\n#### 7.定义函数的方式有哪些，可以写下区别是什么？\n函数的声明方式：\nA.基本语法\n```\nfunction 函数名([参数1],[参数2],...){\n  函数体\n  [return] //返回值\n}\n```\nB.字面量定义的形式(匿名函数)\n```\nvar 变量=function([参数1],[参数2],...){\n  函数体\n  [return] //返回值\n}\n```\nC.以对象的形式来声明\n```\nnew 关键字\nvar 变量=new function([],[]...,\"函数体\");\n```\n#### 8.写出正则表达式，用于匹配字符串至少包含五个连续的中文字，例如 中国人ss中国(注：UTF-8格式中文正则字符编码范围：\\u4e00-\\u9fa5)\n```\nvar str=\"中国人ss中国\";\nvar reg=/\\w/g; 或者var reg=/[a-z]/g; 或者var reg=/[^\\u4e00-\\u9fa5]/g;\nvar arr=str.replace(reg,\"\");\nconsole.log(arr);\n\n输出结果：‘中国人中国’\n```\n#### 9.jquery中的hover事件等效于哪两个事件的组成?\n移入移出事件 onmouseover、onmouseout\n```\n<div class=\"container\">\n  <div class=\"box\"></div>\n</div>\n\n//鼠标移入移出效果\n<script src=\"https://code.jquery.com/jquery-2.2.4.js\">\n$('.container').hover(function(){\n\t$(this).children().fadeOut(1000);\n\t$(this).children().fadeIn(500);\n})\n</script>\n```\n#### 10.JS中哪些情况下会产生undefined值？\n有许多的方法产生一个undefined值的代码。它通常为当试图访问一个不存在的值时。\n1.任何变量声明时没有提供一个初始值，就会返回undefined\n```\nvar foo;\nconsole.log(foo);  //默认值为undefined\n```\n2.当试图访问一个不存在的对象属性或数组项时，返回undefined\n```\nvar array = [1, 2, 3];\nvar foo = array.foo; // foo 属性不存在, 返回 undefined\nvar item = array[5]; // 数组中没有索引为5的项，返回 undefined\nconsole.log(foo,item);\n```\n3.如果省略了函数的返回语句，就会返回undefined\n```\nvar value = (function(){})(); // 返回 undefined\n```\n4.函数调用时提供的参数值为undefined\n```\n(function(undefined){\n    // 参数是 undefined\n})();\n```\n#### 11.获取一个数组中的最大最小值，var numbers=[5,145,11,38,400,78,-834];\n```\nvar numbers=[5,145,11,38,400,78,834];\nvar max=numbers[0];\nfor(var i=0;i<numbers.length-1;i++){\n\tif(max<numbers[i+1]){\n\t\tmax=numbers[i+1];\n\t}else{\n\t\tmax=max;\n\t}\n}\nconsole.log(max);\n\n输出结果'400'\n```\n#### 12.数组有哪些自带的方法或属性\nvar arr=[0,1,2];\n1.pop();删除数组的最后一个元素，减少删除的长度，返回删除的值。\n`这里是2`\n2.push(3);将参数加载到数组的最后，返回新数组的长度。\n`这里是4`\n3.shift();删除数组的第一个元素，返回删除的值，同时数组长度减一。\n`这里是0`\n4.unshift(3,4);把参数加载数组的前面，返回新数组的长度\n`这里是5`\n5.sort();按指定的参数对数组进行排序，返回的值是经过排序之后的数组\n```\nvar arr=[0,1,2,5,4];\nfunction compare(val1,val2){\n\treturn val2-val1;\n}\nconsole.log(arr.sort(compare));\n\n这里是[5, 4, 2, 1, 0]\n```\n6.reverse();反转数组项的顺序，返回的值是经过排序之后的数组\n`这里是[2,1,0]`\n7.contact(3,4);把两个数组拼接起来，返回的值是一个副本\n```\nvar arr=[0,1,2,5,4];\nvar arr2=[7,8,9];\nconsole.log(arr.concat(arr2));\n\n这里是[0, 1, 2, 5, 4, 7, 8, 9]\n```\n8.slice(start,end);返回从元素组中指定开始下标到结束下标之间的项组成的新数组\n```\nvar colors = [\"red\", \"green\", \"blue\", \"yellow\", \"purple\"];\n\n// 一个参数:\nvar color1 = colors.slice(1);\nalert(color1);  // green,blue,yellow,purple\n\n// 两个参数：\nvar color2 = colors.slice(1,4);\nalert(color2);  // green,blue,yellow\n```\n9.splice()\n删除：2个参数，起始位置，删除的项数\n插入：3个参数，起始位置，删除的项数，插入的项\n替换：任意参数，起始位置，删除的项数，插入的任意数量的项\n```\nvar colors = [\"red\", \"green\", \"blue\"];\nvar removed = colors.splice(0,1);  // 删除第一项\nalert(colors);  // green,blue\nalert(removed);  // red,返回数组中只包含一项\n\nremoved = colors.splice(1, 0, \"yellow\", \"orange\");  // 从位置1开始插入两项\nalert(colors);  // green,yellow,orange,blue\nalert(removed);  // 返回的数组是一个空数组\n\nremoved = colors.splice(1, 1, \"red\", \"purple\");  // 从位置I开始插入两项\nalert(colors);  // green,red,yellow,orange,blue\nalert(removed);    // yellow,返回的数组中只包含一项\n```\n10.indexOf()和lastIndexOf();接受两个参数，要查找的项(可选)和查找起点位置的索引\nindexOf();从数组开头向后查找\nlastIndexOf();从数组末尾开始向前查找\n11.every();对数组中的每一项运行给定函数，如果该函数对每一项都返回true，则返回true。\n12.filter();对数组中的每一项运行给定函数，返回该函数会返回true的项组成数组。\n13.forEach();对数组的每一项运行给定函数，这个方法没有返回值。\n14.map();对数组的每一项运行给定函数，返回每次函数调用的结果组成的数组。\n15.some();对数组的每一项运行给定参数，如果该函数对任一项返回true，则返回true。以上方法都不会修改数组中的包含的值。\n16.reduce()和reduceRight();缩小数组的方法，这两个方法都会迭代数组的所有项，然后构建一个最终返回的值。\n17.join(separator);将数组的元素组起一个字符串，以separator为分隔符，省略的话则用默认用逗号为分隔符\n```\nvar a = [1,2,3,4,5];\nvar b = a.join(\"|\"); //a：[1,2,3,4,5] b：\"1|2|3|4|5\"\n```\n#### 13.你想用前端知识做些什么事，如果给你自由的空间\n#### 14.如果让你参与一个前端相关的新技术领域研究，你觉得如何能快速掌握\n", "tag": "技术", "desc": "CSS盒模型包含的元素，子块元素相对于父元素居中", "tags": ["技术"], "created_at": 1500895352, "updated_at": 1500895592, "created_by": 77641313, "id": "5d14a7116d0e6137d6d334d9", "acl": "创建者可读, 创建者可写"}, {"title": "mongoDB相关操作", "content": "本文是有关mongodb一些基础知识积累，算是一个学习笔记，希望对你有帮助，对我也是加深记忆。目前还在学习更新中~\n\n## 数据库分类\n\n关系型数据库 (RDBMS)\n\n关系型数据库中全都是表 (MySql/Oracle/DB2/Sql Server)  \n\n非关系型数据库(NoSql Not only sql)\n\n键值对表(Mongodb/Redis)\n\n修改mongod 数据存放位置\n\n`mongod --dbpath usr/local/data`\n\n## mac环境安装与配置mongodb\n\n## 数据库\n\n数据库的服务器：\n\n* 服务器用来保存数据\n* mongod用来启动服务器\n\n数据库的客户端：\n* 客户端用来操作服务器，对数据进行增删改查操作\n* mongo用来启动客户端\n\n将mongodb设为系统服务，自动在后台启动，不需要每次都手动启动\n\n## 基本概念\n\n数据库(database)\n集合(collection)\n文档(document)\n\n## 基本指令\n\n### 显示当前的所有数据库\n```\nshow dbs\nshow database\n```\n### use 数据库名(进入到指定的数据库中)\ndb (db表示当前所处的数据库)\n### 显示数据库中所有的集合\n`show collections`\n\n## 向数据库中CRUD(增删改查)的操作\n\n### 向数据库中插入文档\n\n`db.<collection>.insert(doc)` 向集合中插入一个或多个文档\n\n> 例子：向test数据库中的students集合中插入一个新的学生对象\n\n插入一个文档：\n`db.students.insert({\"name\":\"daguo\",\"age\":\"27\",\"sex\":\"man\"})`\n\n插入多个文档：\n```\ndb.students.insert([\n    {\"name\":\"daguo\",\"age\":\"27\",\"sex\":\"man\"},\n    {\"name\":\"daguo\",\"age\":\"27\",\"sex\":\"man\"}\n])\n```\n\n当我们向集合中插入文档时，如果没有给文档指定_id属性，则数据库会自动为文档添加_id,该属性用来作为文档的唯一标识\n\n插入一个文档对象：`db.collection.insertOne()`\n插入多个文档对象：`db.collection.insertMany()`\n\nuse test\n### 查询\n\n`db.<collection>.find()` 查询当前集合中的所有文档\n\n`find({})`  表示查询集合中的所有文档\n\n`find({属性：值})` 查询属性是指定值的文档\n\n`find()` 返回的是一个数组\n\n`db.students.find({name:'winter'})`\n\n`db.collection.findOne()` 用来查询集合中符合条件的第一个文档 findOne()返回的是一个文档对象\n\n`db.collection.find().count()  db.collection.find().length()`   查询所有结果的数量\n\n## 更新/修改\n\n`db.collection.update(查询条件,新对象)`  update默认情况下会使用新对象来替换旧对象\n\n如果需要修改指定的属性，而不是替换，需要使用`修改操作符`来完成修改 \n\n`$set`用来修改文档中的指定属性\n\n`$unset`可以用来删除文档的指定属性\n\n`db.collection.updateMany()`    同时修改多个符合条件的文档\n\n`db.collection.updateOne()`     修改一个符合条件的文档\n\n## 删除\n\n一般数据库中的数据都不会删除，所以删除的方法很少调用\n\n一般会在数据中添加一个字段，用来表示数据是否被删除\n\n`db.collection.remove()`    \n\n删除符合条件的所有文档（默认情况下会删除多个）\n\n如果remove({},true) 第二个参数传递一个true,则只会删除一个\n\n```\ndb.colletion.remove({name:'李四'})\n```\n\n`db.collection.deleteOne()`\n\n`db.collection.deleteMany()`\n\n`db.collection.drop()`      删除集合\n\n`db.collection.dropDatabase()`  删除数据库\n\n清空集合\n\n`db.collection.remove({})`  性能较差\n\n`db.collection.drop()`  \n\n## 安装mongodb图形化管理工具\n\n[mongodbmanager](https://www.mongodbmanager.com/download) 貌似只有windows版本\n\n[MongoChef](https://studio3t.com/)  安装包较大\n\n[mongodb compass](https://www.mongodb.com/download-center/compass?filter=enterprise) 最终选择它，mongodb官方GUI\n\n[dbkoda](https://www.dbkoda.com/)\n\n## mongodb操作数据库一些例子\n\n### 1.进入my_test数据库\n\n`use my_test`\n\n### 2.向数据库users集合中插入一个文档\n\n`db.users.insert({name:'daguo',age:'25',address:'shanxi',location:'hangzhou'})`\n\n### 3.查询users集合中的文档\n\n`db.users.find()`\n\n### 4.向数据库users集合中插入一个文档\n\n步骤同2\n\n### 5.查询数据库users集合中的文档\n\n步骤同3\n\n### 6.查询数据库users集合中的文档数量\n\n`db.users.find().count() or db.users.find().length()`\n\n### 7.查询数据库users集合中name为daguo的文档\n\n`db.users.find({name:'daguo'})`\n\n### 8.向数据库users集合中的name为daguo的文档，添加一个address属性，属性值为hangzhou\n\n`db.users.find({name:'daguo'},{$set:{address:'hangzhou'}})`\n\n### 9.使用{name:'gwt'}替换name 为daguo的文档\n\n`db.users.replaceOne({name:'daguo'},{name:'gwt'})`\n\n### 10.删除name为daguo的文档的address属性\n\n`db.users.update({name:'daguo'},{$unset:{address:''}})`\n\n### 11.向name为daguo的文档中，添加一个hobby:{cities:['beijing','shanghai','hangzhou'],movies:['sanguo','hero']}\n\n//mongodb的文档的属性值也可以是一个文档，当一个文档的属性值是另一个文档时，我们称这个文档叫做内嵌文档\n\n`db.users.update({name:'daguo'},{$set:{hobby:{cities:['beijing','shanghai','hangzhou'],movies:['sanguo','hero']}}})`\n\n### 12.向name为gwt的文档中，添加一个hobby:{movies:[\"长城\",\"大黄蜂\"]}\n\n`db.users.update({name:'gwt'},{$set:{hobby:{movies:[\"长城\",\"大黄蜂\"]}}})`\n\n### 13.查询喜欢电影hero的文档\n\n// mongodb 支持直接通过内嵌文档的属性进行查询，如果要查询内嵌文档，则可以通过.的形式来匹配\n\n// 如果要通过内嵌文档来对文档进行查询，此时属性名必须要使用引号\n\n`db.users.find({\"hobby.movies\":\"hero\"})`\n\n### 14.向gwt中添加一个新的电影 绿皮书\n\n// $push用于向数组中添加一个新的元素\n\n// $addToSet 向数组中添加一个新元素，如果数组中已经存在了该元素，则不会添加\n\n`db.users.update({name:'gwt'},{$push:{\"hobby.movies\":\"绿皮书\"}})`\n`db.users.update({name:'gwt'},{$addToSet:{\"hobby.movies\":\"绿皮书\"}})`\n\n### 15.删除喜欢beijing的用户\n\n`db.users.remove({\"hobby.cities\":\"beijing\"})`\n\n### 16.删除users集合\n\n`db.users.remove({})`\n\n`db.users.drop()`\n\n### 17.向numbers中插入20000条数据\n\n//7.2s 性能较低\n```\nfor(var i = 1;i<= 2000;i++){\n    db.numbers.insert({num:i})\n}\n```\n// 只插入一次方法 0.4s\n\n```\nvar arr = [];\nfor (var i = 1;i<= 2000;i++){\n    arr.push({num:i})\n}\ndb.numbers.insert(arr)\n```\n\n### 18.查询numbers中num为500的文档\n\n`db.numbers.find({num:500})`\n\n### 19.查询numbers中num大于5000的文档\n// $gt 大于  $gte 大于等于\n\n`db.numbers.find({num:{$gt:5000}})`\n\n### 20.查询numbers中num小于30的文档\n\n`db.numbers.find({num:{$lt:30}})`\n\n### 21.查询numbers中num大于19996的文档\n\n`db.numbers.find({num:{$gt:19996}})`\n\n### 22.查询numbers中num大于40小于50的文档\n\n`db.numbers.find({num:{$gt:40,$lt:50}})`\n\n### 23.查看numbers集合中的前10条数据\n\n`db.numbers.find({num:{$lte:10}})`\n\n//limit()设置显示数据的上限\n`db.numbers.find().limit(10)`\n//在开发时，绝对不会执行不带条件的查询\n`db.numbers.find()`\n\n### 24.查看numbers集合中的第11条到20条数据\n\n//skip() 用于跳过指定数量的数据  limit()每页显示的条数‘\n//mongodb会自动调整skip和limit的位置\n`db.numbers.find().skip(10).limit(10)`\n\n### 25.查看numbers集合中的第21条到30条数据\n`db.numbers.find().slip(20).limit(10)`\n`db.numbers.find().limit(10).slip(20)`\n\n### 26.将dept和emp集合导入到数据库中\n\n向集合中倒入dept.json和emp.json文件\n\n### 27.查询工资小于2000的员工\n\n`db.emp.find({sal:{$lt:2000}})`\n\n### 28.查询工资在1000——2000之间的员工\n\n`db.emp.find({sal:{$gt:1000,$lt:2000})`\n\n### 29.查询工资小于1000或者大于2500的员工\n\n`db.emp.find({$or:[{sal:{$lt:1000}},{sal:{$gt:2500}}]})`\n\n### 30.查询财务部的所有员工\n\n```\nvar depno = de.dept.find({dname:'财务部'}).deptno;\ndb.emp.find({depno:depno})\n```\n\n### 31.查询销售部的所有员工\n\n```\nvar depno = de.dept.find({dname:'销售部'}).deptno;\ndb.emp.find({depno:depno})\n```\n\n### 32.查询所有mgr为7698的员工\n\n`db.emp.find({mgr:7698})`\n\n### 33.为所有薪资低于1000 的员工加工资400元\n// $inc自增\n`db.emp.updateMany({sal:{$lt:1000}},{$inc:{sal:400}})`\n\n## 文档之间的关系\n\n### 一对一(one to one)\n\n- 夫妻——一个丈夫对应一个妻子，在mongodb中，可以通过内嵌文档的关系来体现出一对一的关系\n\n```\ndb.wifeAndHusband.insert([{name:'冯绍峰',wife:{name:'赵丽颖'}},{name:'黄晓明',wife:{name:'杨颖'}}])\n\n```\n\n### 一对多(one to many / many to one )\n\n用户和订单\n\n```\ndb.users.insert([{name:'swk'},{name:'zbj'}])\n\nswk: user_id: ObjectId(\"5ca9fd0da653d9e932f76b0e\")\nzbj: user_id: ObjectId(\"5ca9fd5ca653d9e932f76b0f\")\n\ndb.orders.insert({list: ['苹果','香蕉','菠萝','凤梨'],user_id: ObjectId(\"5ca9fd0da653d9e932f76b0e\")})\ndb.orders.insert({list:['凉皮','肉夹馍','碗团'],user_id:ObjectId(\"5ca9fd5ca653d9e932f76b0f\")})\ndb.orders.insert({list:['扬州炒饭','西湖醋鱼','糖醋排骨'],user_id:ObjectId(\"5ca9fd0da653d9e932f76b0e\")})\n\n//查找孙悟空的订单\nvar user_id = db.users.findOne({name:'swk'})._id;\ndb.orders.find({user_id:user_id})\n```\n### 多对多(many to many)\n\n老师-学生之间的关系\n\n```\ndb.teachers.insert([\n    {name:'郭德纲'},\n    {name:'于谦'},\n    {name:'冯小刚'}\n])\n\ndb.students.insert([{name:'岳云鹏',teac_id:[ObjectId(\"5cac8e64cd9487edaff8ba61\"),ObjectId(\"5cac8e64cd9487edaff8ba62\")]},{name:'张云雷',teac_id:[ObjectId(\"5cac8e64cd9487edaff8ba62\")]},{name:'郑恺',teac_id:[ObjectId(\"5cac8e64cd9487edaff8ba63\")]}])\n\nvar teac_id = db.teachers.findOne({name:'于谦'})._id; db.students.find({teac_id:teac_id})\n\n```\n\n## sort和投影\n// 查询文档时，默认是按照_id进行排序\n// sort() 可以指定文档的排序规则 sort()中需要传递一个对象来指定排序规则 1表示升序 -1表示降序\n// limt() skip()  sort() 可以以任意的顺序进行调用\n`db.numbers.find().sort({num:-1})`\n`db.numbers.find().sort({num:-1,aa:1})`  //可以指定多个排序规则\n\n// 在查询时，可以在第二个参数的位置来设置查询结果的投影\n可以显示想展示的字段 0表示隐藏 1表示显示\n`db.numbers.find({},{name:1})` //只展示name的结果\n\n`db.numbers.find({},{name:1,_id:0})` //只展示name的结果\n\n## mongoose(https://mongoosejs.com/)\n\nSchema(约束数据库中的文档结构)\n\nModel(相当于collection)\n\nDocument\n\n1.下载安装mongoose\n`cnpm install mongoose --save`\n\n2.在项目中引入mongoose\n`var mongoose = require('mongoose')`\n\n3.连接mongodb数据库\n```\nmongoose.connect('mongodb://数据库的ip地址：端口号/数据库名',{useMongoClient:true})\n\n-- 如果端口号是27017(mongodb默认端口号) 则可以忽略不及\n```\n\n4.断开数据库连接(一般不需要调用)\nmongodb数据库，一般情况下，只需要连接一次，连接一次之后，除非项目停止/服务器关闭，否则连接一般不会断开\nmongoose.disconnect()\n\n监听MongoDb数据库的连接状态\n 在mongoose对象中，有一个属性叫做connection，该对象表示的就是数据库连接\n 通过监听该对象的状态，可以来监听数据库的连接与断开\n\n ```\n 数据库连接成功的事件\n mongoose.connection.once('open',function(){\n\n })\n\n 数据库断开的事件\n mongoose.connection.once('close',function(){\n\n })\n ```\n\n## 向数据库中插入文档（增加）\n\n```\nvar mongoose = require('mongoose');\n// 连接数据库\nmongoose.connect('mongodb://127.0.0.1:27017/mongoose_test',{useNewUrlParser: true});\nmongoose.connection.once('open',function(){\n    console.log('数据库连接成功～');\n})\n\n// 将mongoose.Schema 赋值给一个变量\nvar Schema = mongoose.Schema;\n\n// 创建Schema模式对象\nvar StuSchema = new Schema({\n    name: String,\n    age: Number,\n    gender: {\n        type: String,\n        default: 'female'\n    },\n    address: String\n})\n\n// 通过Schema来创建Model\n// Model代表数据库中的集合，通过Model才能对数据库进行操作\n// mongoose.model(modelName, schema);\n// modelName 代表映射的结合名 mongoose会自动将集合变为复数\nvar StuModel = mongoose.model(\"student\",StuSchema)\n\n// 向数据库中插入一个文档\n// StuModel.create(doc,function(err){})\nStuModel.create({\n    name: '郭德纲',\n    age: 44,\n    gender: 'male',\n    address: '浙江省杭州市西湖区'\n},function(err){\n    if(!err){\n        console.log('文档插入成功～');\n    }\n})\n```\n\n## 数据库查询\n\n参考文档：https://mongoosejs.com/docs/guide.html\n\n```\nvar StuModel = mongoose.model(\"student\",stuSchema);\n/*\n    有了Model就可以对数据库进行增删改查的操作了\n    Model.create(doc(s),[callback])\n    用来创建一个或多个文档，并添加到数据库中\n    参数：\n        doc(s) 可以是一个文档对象，也可以是一个文档对象的数组\n        callback 当操作完成以后调用的回调函数\n\n    查询的：\n        Model.find(conditions,[projection],[options],[callback])\n        - 查询所有符合条件的文档  总会返回一个数组\n        Model.findById(id,[projection],[options],[callback])\n        - 根据文档的id属性查询文档\n        Model.findOne([conditions],[projection],[options],[callback])\n        - 查询符合条件的第一个文档  总会返回一个具体对象\n\n        conditions 查询的条件\n        projection 投影\n            - 两种方式\n                {name:1,_id:0}  \"name -_id\"\n        options 查询选项(skip limit)\n        callback 回调函数，查询结果会通过回调函数返回\n                 回调函数必须传递，否则将不会查询\n*/\n\nStuModel.create([],function(err){\n    if(!err){\n        console.log('文档插入成功~');\n    }\n})\n\nStuModel.find({},function(err,docs){\n    if(!err){\n        console.log(docs);\n    }\n})\n\n//输出结果(将该表所有结果返回)\n[{_id:,name:'孙悟空',age:18,address:'花果山',_v:0,gender:'male'},{_id:,name:'沙和尚',age:28,address:'流沙河',_v:0,gender:'male'}]\n\nStuModel.find({},{name:1,_id:0},function(err,docs){\n    if(!err){\n        console.log(docs);\n    }\n})\n\n//输出结果(返回文档只包含字段name) name:1 name显示 _id:0 _id隐藏\n[{name:'孙悟空'},{name:'白骨精'},{name:'猪八戒'},{name:'沙和尚'}]\n\nStuModel.find({},\"name age -_id\",function(err,docs){\n    if(!err){\n        console.log(docs);\n    }\n})\n\n//输出结果 -_id代表_id属性隐藏\n[{name:'孙悟空',age:18},{name:'白骨精',age:16},{name:'猪八戒',age:28},{name:'沙和尚',age:38}]\n\n```\n\n## 数据库修改\n\n```\n/*\n    修改\n    Model.update(conditions,doc,[options],[callback])\n    Model.updateMany(conditions,doc,[options],[callback])\n    Model.updateOne(conditions,doc,[options],[callback])\n    用来修改一个或多个文档\n    参数：\n        conditions 查询条件\n        doc 修改后的对象\n        [options] 配置参数\n        callback 回调函数\n    Model.repalceOne(conditions,doc,[options],[callback])    \n*/\n\n// 修改郭德纲的地址为天津市\n\n// StuModel.updateOne({name:'郭德纲'},{$set:{address:'天津市'}},function(err){\n//     if(!err){\n//         console.log('修改成功！');\n//     }\n// })\n\n// StuModel.updateOne({_id:'5cb2887033358d0babf3fe6f'},{$set:{name:'赵本山'}},function(err){\n//     if(!err){\n//         console.log('修改成功～');\n//     }else{\n//         console.log(err);\n//     }\n// })\n```\n\n## 数据库删除\n\n```\n/*\n    删除\n    Model.remove(conditions,[callback])\n    Model.deleteOne(conditions,[callback])\n    Model.deleteMany(conditions,[callback])\n*/\n\n// StuModel.create([\n//     {\n//         name: '吴京',\n//         age: 34,\n//         gender: 'male',\n//         address: '北京市朝阳区'\n//     },{\n//         name: '陈道明',\n//         age: 61,\n//         gender: 'male',\n//         address: '贵州市'\n//     }\n// ],function(err){\n//     if(!err){\n//         console.log('文档插入成功～');\n//     }\n// })\n\n// StuModel.remove({name:'王铁锤'},function(err){\n//     if(!err){\n//         console.log('删除文档成功～')\n//     }\n// })\n```\n\n## 文档的属性和方法\n\n```\n// var stu = new StuModel({\n//     name: '岳云鹏',\n//     age: '35',\n//     gender: 'male',\n//     address: '河南省商丘市'\n// })\n\n/*\n    document方法\n        Model#save([options],fn)\n*/\n// stu.save(function(err){\n//     if(!err){\n//         console.log('保存成功～')\n//     }\n// })\n\nStuModel.findOne({},function(err,doc){\n    if(!err){\n        // console.log(doc);\n        /*\n            update(update,[options],[callback])\n            - 修改对象\n            remove([callback])\n            - 删除对象\n         */\n        // doc.update({$set:{age:25}},function(err){\n        //     if(!err){\n        //         console.log('修改成功～');\n        //     }\n        // })\n        // doc.name = 'gwt';\n        // doc.save()\n\n        // doc.remove(function(err){\n        //     if(!err){\n        //         console.log('删除成功！');\n        //     }\n        // })\n\n        /*\n            get(name)\n            - 获取文档中的指定属性值\n            set()\n            - 设置文档的指定属性值\n            id\n            - 获取文档的属性值\n            toJSON()\n            - 转换为一个JSON对象\n            toObject()\n            - 将Document转换为一个普通的JS对象\n                转换为普通的JS对象之后，所有的Document对象的方法或者属性就不能使用了\n        */\n        // console.log(doc.get('name'));\n        // console.log(doc.name);\n\n        // doc.set(\"name\",\"daguo\");  //数据库中值不变\n        // doc.name = 'gwd'\n        // console.log(doc);\n\n        // console.log(doc.id);\n        // console.log(doc._id);\n\n        var o = doc.toObject();\n        console.log(o);\n        console.log(o.id) //undefined\n        console.log(o._id);\n        delete o.address;\n        console.log(o);\n    }\n})\n```\n\n## 公用模块封装\n\n连接数据库/创建模型对象\n\n`mongodb/models/student.js  mongodb/tools/con_mongo.js`", "tag": "技术", "desc": "有关mongodb一些基本概念、指令、图形化管理工具、查询方法以及mongoose", "tags": ["技术", "mongoDB"], "created_at": 1554728574, "updated_at": 1554728574, "created_by": 77641313, "id": "5d172ca03aaa5627eac4f8ec", "acl": "创建者可读, 创建者可写"}, {"title": "依旧是有关小程序的一篇", "content": "感觉依旧是同小程序相关，上个月依旧是在做小程序项目，公司新开发了两个小程序，自己的个人小程序也在上月开发完成，完成审核上线。\n\n### 个人小程序开发\n\n先聊聊个人小程序吧，小程序名“奉壹杂记”，有关于博客的一个小程序，现有文章列表页、文章详情页两个页面。列表页涉及接口请求，分页、分享，文章详情页有单条数据查询，`towxml`将markdown数据转换为支持小程序语法的语言，关于前端的东西就不再多聊，因为相比较于之前开发的内容，简直太过于简单。主要是想谈谈后台的构建，后台选择了知晓云，通过调用sdk的方式来实现前后台交互，知晓云后台封装了很多常用的基本功能：数据增删改查、微信支付、获取用户openid、发送模板消息、微信授权等等，面向的便是对后台要求不高以及成本较低的独立开发者或者是小公司。他会帮你提供小程序开发的那些基本条件：https的相关域名配置（毕竟这些如果要自己去准备的话，流程确实比较麻烦，网站备案、域名认证、ssr的https加密、独立服务器等，成本确实不低），但知晓云基础版本套餐只需要一天三毛，便可以很快捷的部署一个自己的小程序。\n\n做了几乎一年多的小程序开发，流程已经太过于熟悉，提交的小程序代码审核次数感觉已经快超过了百次，但独立开发出属于自己的小程序，那感觉还是挺不一样，激动了好一会儿~ 当前，个人小程序的开发并没那么一帆风顺，审核失败了两次，第一次官方给出的回复是个人小程序不支持文娱类目，想了想估计是文章里边“娱乐”性的内容有点多，有几篇“心灵鸡汤”和“游记”。而关于“审核不通过”这个问题，也有足够的经验来应付，而不是看到这个词眼就搂不住马上跑去社区吐槽...官方回复的一般是模棱两可，并不那么“直观”，只能是猜个“大意”，然后去修改\n\n这事拖了大概有一周才又拾起来，优化了两个页面的代码，列表页加上了分页（之前是将所有数据全部返回），详情页通过id走接口获取单条数据（之前通过传参方式将数据传递到详情页），markdown转wxml代码优化，两个页面分享。细节内容还不少，但改起来并未耗费多久，也就两个小时左右。重新提交审核，然后，又没通过...\n\n这次没通过是的原因是让我说明知晓云sdk插件在本小程序的具体用途，说明之后，重新提交代码审核。\n\n个人经验，开发小程序技术是一方面、另一方面还需要有强大的心理素质，毕竟审核不通过这种问题也会经常“莫名其妙”的发生，而重复提交仍不通过也并不奇怪，所以，足够的耐心是必备要素！曾经遇到过“小程序IOS虚拟支付”、“诱导分享朋友圈”等问题，而这些都是在没有任何“征兆”情况被通知。然后便有了三天的工作都在解决“审核不通过”的问题，把可能情况都修改并提交多次审核仍不通过，社区发表了好多次帖子，最后才知道问题是因为首页的一个弹窗（哭笑不得）\n\n### 公司小程序开发\n\n公司小程序开发前期的认证流程比较麻烦，需要各种各样公司相关手续，营业执照、开户许可、税务证明、微信公函（需公司盖章）、以及管理员相关信息（一个管理员最多可绑定5个小程序），公司小程序认证需要300块的认证费用。另，认证完成之后，需要填写小程序相关信息（诸如头像、小程序名、简介）。这一步通过之后，代码才能提交审核。不然会影响小程序上线进度\n\n公司小程序开发自然比个人小程序麻烦很多，业务逻辑就会复杂很多，该有的功能也基本都有，微信手机号授权、手机验证码登录、图片上传、图表等一些日常的业务逻辑，按需求完成即可\n\n不管是公司还是个人，核心内容都相同，无非是业务逻辑不同、复杂度不同。下个月分享点别的内容，不然真是都同小程序相关了（捂脸笑），其实也研究了好多其他方面的内容，只是因为懒，然后就~（苦笑）", "tag": "技术", "desc": "依旧是同小程序相关，有关于个人小程序和公司小程序开发的一点心得、感悟~", "tags": ["技术", "小程序"], "created_at": 1562318340, "updated_at": 1562318447, "created_by": 77641313, "id": "5d1f16452d4a68171c799ef5", "acl": "创建者可读, 创建者可写"}, {"title": "有关全屏h5页面踩的一些坑", "content": "## 前言\n\n最近一个需求，涉及一个页面，但是却做了3天...有必要总结下这心路历程，毕竟糟心的点那么多\n\n主要糟心的地方在于前端的兼容性问题，做的是一个全屏滚动的页面，有5个部分，每个部分的核心内容为一个全屏的图片，听着很简单，但却遇到了不少问题\n\n## 内容\n\n1. 使用fullpage报错问题\n\n全屏滚动方式采用fullpage插件实现，主要原因是swiper用的太多了，想换一种方式写一写，顺便探探这个插件的优劣\n\n恶心的地方便是使用最新fullpage.min.js会报一个错，大致意思是让输入licenseKey关键秘钥之类的东西，获取该秘钥需要支付XXX$，好吧，一直以为它是开源插件。后改成fullpage.min.js3.0.3版本，不是最新版本，licenseKey传值'OPEN-SOURCE-GPLV3-LICENSE'(差不多就是开源项目中使用的意思)\n\n2. 图片尺寸兼容适配问题\n\n设计稿的尺寸是750*1334，但屏幕宽高并不是750*1334，有的屏幕长(比如iphoneX)，有的屏幕比较短，另外有的浏览器有头部也会占用一部分高度。如果宽度设为100%之后，要想保持图片比例，必然是无法全部都考虑到。比如：短屏中可能显示不全，长屏又空一部分。而统一将图片宽高设置为100%，在一些短屏中又出现压缩，长屏中出现拉伸情况\n\n后经综合考虑，改为背景图片方式`background-size:cover;background-position:center center;`将短的部分完全显示，经测试大部分情况都可以考虑到。不足之处在于iphoneX可能会有左右两侧显示不全情况，真机测试情况还好，并没调试工具看到那么糟糕\n\n还有一种解决思路是用img标签，设置`min-height:100%`，短屏会按照图片比例显示，长屏则显示100%，将图片居中即可\n\n但不管是哪种方式，终归不能全部都考虑到，所以需要采用一个彼此(产品和开发)都可以接收的方式\n\n3. input输入框输入完成之后页面无法恢复\n\ninput输入框获取光标，页面上移，当输入完成之后，页面并不恢复(还是处于上移状态)\n\n解决方式：\n\n```\nvar isFocus = false;        //光标是否聚焦\n解决ios键盘收起 页面内容不下滑(多个输入框情况)\n$('input,textarea').on('blur',function(){\n    isFocus = false;\n    setTimeout(function(){\n        if(!isFocus){\n            window.scroll(0,0);\n        }\n    },500)\n});\n$('input').on('focus',function(){\n    isFocus = true;\n})\n//单个输入框情况\n$('input,textarea').on('blur',function(){\n    window.scroll(0,0);\n})\n```\n多个输入框情况(当一个输入框输入完成之后，立即点击另一个输入框获取焦点) 需设置延迟获取光标状态，如为true，则代表已跳转另一个输入框。否者代表用户已关闭软键盘，此时页面需收缩\n\n单个输入框则只需要直接恢复即可\n\n移动端输入完成之后跳转至下一个输入框(点击软键盘\"完成\"或者是\"换行\")\n\n```\nfunction focusNextInput(thisInput){\n    var inputs = $('input');\n    for(var i = 0;i<inputs.length;i++){\n        // 如果是最后一个，则焦点回到第一个\n        if(thisInput[0] == inputs.eq(i)[0]){\n            if(i == (inputs.length-1)){\n                window.scroll(0,0);\n            }else{\n                isFocus = true;\n                inputs[i+1].focus(); break;\n            }\n        }\n    }\n}\n```\n\n具体思路看代码~\n\n4. 背景音乐问题\n\n产品(好吧其实是运营)提需求，需要给网页加一个背景音乐，能够打开直接播放的那种，然后要气势磅礴、音乐要截取中间高潮的部分...\n\n之前有做过类似需求，最开始考虑的问题可能只是在一些浏览器中无法自动播放问题，因为一般浏览器都会默认阻止自动播放。而要满足需求，微信浏览器中一般会监听原生方法去执行播放事件，safari浏览器会触摸之后再去播放\n\n音乐标签\n\n```\n<audio src=\"\" height=\"0\" width=\"0\" id=\"bgMusic\" autoplay loop>\n    <source src=\"\">\n</audio>\n```\n\nJS相关逻辑\n\n```\nvar voice = document.getElementById('bgMusic');\nvoice.play()\n//判断 WeixinJSBridge 是否存在\nif (typeof WeixinJSBridge == \"object\" && typeof WeixinJSBridge.invoke == \"function\") {\n    voice.play();\n} else {\n    //监听客户端抛出事件\"WeixinJSBridgeReady\"\n    if (document.addEventListener) {\n        document.addEventListener(\"WeixinJSBridgeReady\", function () {\n            voice.play();\n        }, false);\n    } else if (document.attachEvent) {\n        document.attachEvent(\"WeixinJSBridgeReady\", function () {\n            voice.play();\n        });\n        document.attachEvent(\"onWeixinJSBridgeReady\", function () {\n            voice.play();\n        });\n    }\n}\n\n//voiceStatu用來记录状态,使 touchstart 事件只能触发一次有效,避免与 click 事件冲突\nvar voiceStatu = true;\n//监听 touchstart 事件进而调用 <audio> 元素提供的 play() 方法播放音频\ndocument.addEventListener(\"touchstart\", function (e) {\n    if (voiceStatu) {\n        voice.play();\n        voiceStatu = false;\n    }\n}, false);\n```\n\n播放相关api\n\n```\nif(voice.paused){   //判断是否暂停\n    voice.play();   //音频播放\n}else{\n    voice.pause();  //音频暂停\n}\n```\n\n嗯，本以为这样就结束了，把之前的代码找出来，拷贝过去，几分钟搞定。但，还是太年轻。\n\n大部分时间花费在了音频截取、音频压缩上。事后感觉也就这，但却也浪费了一天时间，过程并不美好。音频截取找了好多软件，要么不能用，要么要收费，后边选用了QQ影音来截取，输出为mp3格式。将音频放上去之后才发现，页面加载需要很长时间才能播放，后测试wma、m4a格式，发现依旧如此。判定同格式无关，只能是音频大小问题(3M左右)。\n\n经过压缩后还有1M左右，只能将原音频又截短了一部分，留了大概一分钟时长，再压缩(剩600K)。基本可以满足要求，加载也不会那么慢\n\n当然也会有音乐的暂停和开始播放那种需求，不过也基本上调用api即可\n\n## 结尾\n\n看似简单的内容却耗费很长时间，而且这事越急越乱，问题仍需要一个个去解决。\n\n本不想总结这样的内容，觉得没必要，也就一个h5，相比于以往处理过的问题，可能也就只是另一个问题而已。\n\n但转瞬一想，当自己在遇到问题时，往往会去搜索别人的解决方法。最终问题能够解决，得益于网络上那么多人愿意去分享自己的经验。而今天把自己的解决思路也写出来，日后说不准也能够帮到别人。\n\n倘若每个人都不总结分享了，那岂不是日后都搜不到结果？或者是人人都需要踩一遍坑才能解决问题？", "tag": "技术、H5", "desc": "全屏页面使用fullpage报错，图片尺寸兼容适配、input输入框输入、背景音乐播放等问题处理", "tags": ["技术", "H5"], "created_at": 1563355046, "updated_at": 1563355051, "created_by": 77641313, "id": "5d2ee7befa63a7235e7cae78", "acl": "创建者可读, 创建者可写"}, {"title": "PC小程序公测", "content": "8月8号PC小程序公测，配合开发工具版本：1.02.1908082，微信版本：微信测试版2.7.0.65 \n\n最直接的一个好处便是在PC端也可以直接打开好友分享的小程序。\n\n另一个便是调试线上小程序，移动端分享给好友，PC端调试模式下打开小程序，跳转到PC调试模式，可以查看console等等信息。之前移动端分享直接打开线上程序，没法有效修改代码在控制台输出相应信息\n\n不过不知道android和ios这个怎么分的？现在windows打开的是安卓版，难道mac打开的是ios版？mac测试版目前还没有推出，等推出后下载看看\n\n现有的一个问题是貌似不支持touch滑动事件、微信支付、canvas画布支持度也不太高等，估计微信后续会解决掉\n\n这是在PC端打开的截图：\n\n![wx_01](http://imgs.wdcorner.cn/wx_01.png)\n\n![wx_02](http://imgs.wdcorner.cn/wx_02.png)\n\n看着界面还不错，像是在平板中打开的样子\n\nPC端打开小程序，后台日志中agent方式是什么样？以及小程序后台数据统计又归于哪一类都需要去额外注意\n\nPC端打开小程序这个功能是否可以带来额外的数据增长，以及开发者是否需要适配PC端，还需要等正式版本发布之后查看\n", "tag": "小程序", "desc": "8号小程序公测，配合开发工具版本：1.02.1908082，微信版本：微信测试版2.7.0.65 ", "tags": ["小程序"], "created_at": 1565580060, "updated_at": 1565580494, "created_by": 77641313, "id": "5d50db5099562a3aaae6718d", "acl": "创建者可读, 创建者可写"}]}